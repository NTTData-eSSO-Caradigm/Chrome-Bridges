﻿//////////////////////////////////////////////////////////////////////////////
//
// Description:       Bridge - autogenerated script based on 
//                    Bridge Wizard SBMtemplate.js.
//
// Application:       c90_eTenet_IE11 
//
// Description:       This was a test bridge for 6.4     
//
// Version:           6.4.53479.20430
//
// Filename:          c90_eTenet_IE11.js 
//
// Generated Date:    7/5/2017 12:27:12 PM 
//
// Language:          English (United States)
//
//  Copyright:      Copyright 2013 Caradigm. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////////////

@import ".\Sentillion Performance Framework\2.2\spf.js"
@import ".\Sentillion Performance Framework\2.2\sbmPlugin.js"
@import ".\Sentillion Performance Framework\2.2\tracePlugin.js"
@extend ".\Sentillion Performance Framework\2.2\ParseCommandLine.js"
var BUILD_VERSION = "6.4.53479.20430";

///////////////////////////////////////////////////////////////////////////
var WIZARD_BUILD_VERSION = "6.4.53479.20430"; // Build of the Bridge Wizard

////////////////////////   BEGIN DECLARATION //////////////////////////////
var BridgeOptions =
{
    EnableTraceLog:         true,     // enable logging activity by Actions/SPF
    showTraceWindow:        false,      // enable the BridgeWorks interactive trace viewer

    ApplicationName:        "c90_eTenet_IE11",
    ApplicationVersion:     "", // not implemented by wizard

    // Spf defines the user context item name in two parts: UserKey and
    // ApplicationSuffix, for example:
    //
    //    user.id.logon + .mirrormed
    //
    // Both parts are set automatically by spf, however you can change either part by
    // setting these two lines below.

    //UserKey:                "user.id.logon",
    ApplicationSuffix:      BWSystem.AppSuffix,       // uses bridge vault suffix by default

    // link status display state
    LinkStatusEnabled:      false,    

    // Bridge locks to be used for apps that require foreground
    BridgeLockEnabled:      false,    

    // if user link supported    
    UserLinkOn:          true,        // user link on or off

    // if patient link supported    
    PatientLinkOn:          false,        // patient link on or off

    // if reauthentication is supported
    ReauthenticationEnabled: false,        // reauth enabled true or false

    // if reauthentication is supported
    MultipleBridgeInstancesEnabled: true,        // multiple bridge instances true or false

    SSOOnlyMultipleBridgeInstances: false,        // SSO Only multiple bridge instances true or false

    PatientKeyName:         "patient.id.mrn.ccow",
//  This code can be removed if the actions value input for WaitWindowTextChange supports regexp
/**/ValidMRNRegexp:         "^(\\d+)$", 

    // for apps that require the minimize-restore-resume pt. strategy
    AutoMinimizeOnClearPatient: false,
    AutoMinimizeOnPatientSearch: false,

    ForceLogout:            false,
    RestartEnabled:         false,              // for apps that do not have a logout feature and must be restarted

    EnableRepeatedLogins:   false,       // keep app logged in by repeating the login process as needed

    PasswordLearnMaxAttempts:  3,  // 0 to disable
    SelfEnrollmentMaxAttempts: 3,   // 0 to disable
    MaxReAuthAttempts:         0,               // max number of re-authentication attempts (0 to disable)

    LoginFailsafeDelay:     Seconds(20), 
    LogoutFailsafeDelay:    Seconds(20), 

    OnProcessesTerminatedTimeout:   Seconds(4),

    moveToWorkArea:         true,
    
    TerminateOnContextChange:   false,
    TerminateOnApplicationTimeOut:  false,
    TerminateOnManualLogout:    false,
    
    ManualChangePassword:   false,
    
    SetNullPatientOnContextChange:    false,
    ForceClearPatient:  false,
    
    StripDomainFromUIdValue:  false,

    RequiresVersion:        '2.2',   // spf version must be >= template version
    RequiresBW:             '2.4.5',
    autoTerminate:          false,               // let bridge always control whether bridge is terminated on app exit


    // Change of behavior, but recommended
    AutoCloseZeroSize:      false,
    AutoCloseOffScreen:     false
};

///////////////////////////////////////////////////////////////////////////
var shutdownKnownProcessNames = [];

///////////////////////////////////////////////////////////////////////////
var ApplicationLaunchArgMap =
{
    ShutdownOnChange:   true,
    AppType:            AppLaunch.isWebApplication,
    LaunchIE:           false,
    AppUrl:             "https://secure.etenet.com/"};

///////////////////////////////////////////////////////////////////////////
var MonitorUrls = [
  "*.etenet.com/*",
  "icon.coniferhealth.com/Pages/*"
];

///////////////////////////////////////////////////////////////////////////
var Windows =
{
    InvalidPasswordDismiss1_window_0:
       {
           classname:"#32770",
    controlClassname:"Static",
         controlPath:"[3]",
         controlText:"*You must enter both a User ID and a password to log in.*",
         processName:"IEXPLORE.EXE",
           signature:"ElgXrGi0/HbxSKiyUwhDnw==",
               title:"Message from webpage*"
       }
 
};

///////////////////////////////////////////////////////////////////////////
var Pages =
{
    Logon_web_0:
       {
           signature:"RmGObK/RTbuU5HETgY/ZNA==",
               title:"eTenet II",
   uniqueElementPath:"INPUT#Text1",
   uniqueElementText:"*",
                 url:"https://secure.etenet.com/publicsite/default.asp?URL=%2f"
       }
,
    LogonSuccess1_web_0:
       {
           signature:"vZyPfZvyyJ+fqj2/WIvtjw==",
               title:"Home",
   uniqueElementPath:"A#ctl00_IdWelcome_HyperLinkSignOut",
   uniqueElementText:"*Logout*",
                 url:"https://portal.etenet.com/pages/home.aspx"
       }
,
    LogonSuccess2_web_0:
       {
           signature:"OTZf3jM9JY/prXWyNnNbyg==",
               title:"Home",
   uniqueElementPath:"A#zz5_Menu.SPAN[0]",
   uniqueElementText:"*",
                 url:"https://icon.coniferhealth.com/Pages/default.aspx"
       }
,
    LogonSuccess3_web_0:
       {
           signature:"OQ53XPkqxJT6dcXepgvG+Q==",
               title:"Physician Portal",
   uniqueElementPath:"A#LogoutLinkButton",
   uniqueElementText:"*LogOut*",
                 url:"https://physicianportal.etenet.com/PhysicianPortal/Default.aspx"
       }
,
    InvalidPasswordDismiss2_web_0:
       {
           signature:"jnGMxw7P6dACQ+ZQW3AQZQ==",
               title:"eTenet I",
   uniqueElementPath:"FORM#form1.TABLE[0].TBODY[0].TR[0].TD[0].DIV[0].DIV[0].DIV[1].DIV[0]",
   uniqueElementText:"*NOTE: The User ID and password you provided did not result in a match. If you have forgotten your User ID, your password, or if you believe you have entered your correct password, please reset your password before attempting to login again. Click here to reset password.*",
                 url:"https://secure.etenet.com/PublicSite/default.asp?Action=LoginFailed&FailedLoginCount=*"
       }
 
};

///////////////////////////////////////////////////////////////////////////
var DriveToLogonSequences = [];

///////////////////////////////////////////////////////////////////////////
var ReauthenticationSequences = [];

///////////////////////////////////////////////////////////////////////////
var CloseDialogsSequences = [];

///////////////////////////////////////////////////////////////////////////
var Logon =
[
    Actions.SetTextEx(
       {
        controlClass:"INPUT",
         controlText:"*",
         elementPath:"INPUT#Text1",
           mechanism:true,
           sendchars:false,
               value:"%USERNAME%",
              webdef:Pages.Logon_web_0
       }
    ),
    Actions.SetTextEx(
       {
        controlClass:"INPUT",
         controlText:"*",
         elementPath:"INPUT#Password1",
           mechanism:true,
           sendchars:false,
               value:"%PASSWORD%",
              webdef:Pages.Logon_web_0
       }
    ),
    Actions.PressButtonEx(
       {
        controlClass:"INPUT",
         controlText:"*Log In*",
         elementPath:"INPUT#btnlogin",
              webdef:Pages.Logon_web_0,
                   x:"1058",
                   y:"457"
       }
    )
];
Logon.seqname = "Logon";
var LogonSuccess1 =
[
         Actions.WaitEx(
       {
        controlClass:"A",
         controlText:"*Logout*",
         elementPath:"A#ctl00_IdWelcome_HyperLinkSignOut",
              enable:true,
             visible:true,
          waitoption:"WaitControl",
              webdef:Pages.LogonSuccess1_web_0
       }
    )
];
LogonSuccess1.seqname = "LogonSuccess1";
var LogonSuccess2 =
[
         Actions.WaitEx(
       {
        controlClass:"SPAN",
         controlText:"*GALVAN, BRENDA*",
         elementPath:"A#zz5_Menu.SPAN[0]",
              enable:true,
             visible:true,
          waitoption:"WaitControl",
              webdef:Pages.LogonSuccess2_web_0
       }
    )
];
LogonSuccess2.seqname = "LogonSuccess2";
var LogonSuccess3 =
[
         Actions.WaitEx(
       {
        controlClass:"A",
         controlText:"*LogOut*",
         elementPath:"A#LogoutLinkButton",
              enable:true,
             visible:true,
          waitoption:"WaitControl",
              webdef:Pages.LogonSuccess3_web_0
       }
    )
];
LogonSuccess3.seqname = "LogonSuccess3";
var LogonSuccessSequences = [LogonSuccess1,LogonSuccess2,LogonSuccess3];

///////////////////////////////////////////////////////////////////////////
var InvalidPasswordDismiss1 =
[
         Actions.WaitEx(
       {
        controlClass:"Static",
         controlPath:"65535",
         controlText:"*You must enter both a User ID and a password to log in.*",
              enable:true,
             visible:true,
          waitoption:"WaitControl",
           windowdef:Windows.InvalidPasswordDismiss1_window_0
       }
    ),
    Actions.PressButtonEx(
       {
        controlClass:"Button",
         controlPath:"2",
         controlText:"*OK*",
         doubleClick:false,
           mechanism:2,
           windowdef:Windows.InvalidPasswordDismiss1_window_0,
                   x:"43",
                   y:"14"
       }
    )
];
InvalidPasswordDismiss1.failreason = 2;
InvalidPasswordDismiss1.seqname = "InvalidPasswordDismiss1";
var InvalidPasswordDismiss2 =
[
         Actions.WaitEx(
       {
        controlClass:"DIV",
         controlText:"*NOTE: The User ID and password you provided did not result in a match. If you have forgotten your User ID, your password, or if you believe you have entered your correct password, please reset your password before attempting to login again. Click here to reset password.*",
         elementPath:"FORM#form1.TABLE[0].TBODY[0].TR[0].TD[0].DIV[0].DIV[0].DIV[1].DIV[0]",
              enable:true,
             visible:true,
          waitoption:"WaitControl",
              webdef:Pages.InvalidPasswordDismiss2_web_0
       }
    )
];
InvalidPasswordDismiss2.failreason = 2;
InvalidPasswordDismiss2.seqname = "InvalidPasswordDismiss2";
var InvalidPasswordSequences = [InvalidPasswordDismiss1,InvalidPasswordDismiss2];

///////////////////////////////////////////////////////////////////////////
var ExpiredPasswordDismissSequences = [];

var ExpiredPasswordSequences = [];

///////////////////////////////////////////////////////////////////////////
var LogoutSequences = [];

var LogoutSuccessSequences = [];

///////////////////////////////////////////////////////////////////////////
var CustomSequences = [];

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
var Services =
{
    Logon:                     LoginDrivers,
    PerformRequest:            function () { trace("perform request undefined"); },
    
    LogoutSequences:           LogoutSequences,
    
    shutdownKnownProcessNames: shutdownKnownProcessNames,
    ApplicationLaunchArgMap:   ApplicationLaunchArgMap,
    BridgeOptions:             BridgeOptions,
    MonitorUrls:               MonitorUrls,
    Windows:                   Windows,
    Pages:                     Pages,
    onAppTerminate:            OnTerminateApplication
};

///////////////////////////////////////////////////////////////////////////
var MonitorUrlsRegEx = [];

////////////////////////   END DECLARATION //////////////////////////////

///////////////////// BEGIN GENERATED FUNCTIONS //////////////////////////

// define trace() - required for use with tracePlugin.js
function trace() 
{ 
  var callinfo = { caller: trace.caller, 
                   moduleName: BWSystem.BridgeName }; 
  
  spf.trace._outputdriver.apply( callinfo, arguments );                      
} 

///////////////////////////////////////////////////////////////////////////
// spf overrides
//$$entry, OnBeginBridge, null 
//$$exit, OnBeginBridge 
//$$entry, CustomInitialize, null 
//$$exit, CustomInitialize 
//$$entry, VerifyUniqueElement(screen, windowdef), null 
//$$exit, VerifyUniqueElement 
//$$entry, IsWindowProcess(window), null 
//$$exit, IsWindowProcess
//$$entry, IsBrowserProcess(browser), null 
//$$exit, IsBrowserProcess 
//$$entry, VerifyUniquePageElement(browser, webdef), null 
//$$exit, VerifyUniquePageElement

function Initialize()
{
    // override code
    if (__override(null, 'Initialize'))
    {
        return;
    }
    //$$entry, Initialize, null 
    traceToString = tracePlugin.traceToString;

    trace();

    Minutes = spf.Minutes;
    Seconds = spf.Seconds;
    Action = spf.Actions.Action;
    Execute = spf.Actions.Execute;

    AppLaunch = spf.AppLaunch;
    Include = spf.Include;

    // init mon urls
    InitMonitorUrls();

    //$$exit, Initialize
}

///////////////////////////////////////////////////////////////////////////
function InitMonitorUrls()
{ 
    // optimize MonitorUrls
    MonitorUrlsRegEx = [];

    for ( var i in MonitorUrls )
    {
        var monUrl = splitUrlRegEx( MonitorUrls[i] );
        if ( monUrl )
            MonitorUrlsRegEx.push( monUrl );

    }

}

///////////////////////////////////////////////////////////////////////////
function main()
{
    // override code
    if (__override(null, 'main'))
    {
        return;
    }
    //$$entry, main, null 
    trace( "Wizard Build Version:", WIZARD_BUILD_VERSION );
    trace( "Bridge Name:", BWSystem.BridgeName );
    trace( "App Suffix:", BWSystem.AppSuffix );

    // parse command line first so we can override 
    ParseCommandLine();

    //if the bridge already running and the bridge is configured to run multiples instances, and also configured to run subsequent instances as SSO only
    if((BWSystem.IsBridgletRunning(BWSystem.BridgeName)) && 
        (BridgeOptions.MultipleBridgeInstancesEnabled) && 
        (BridgeOptions.SSOOnlyMultipleBridgeInstances))
    {
        trace("Running multiple bridge instances as SSO Only");
        BridgeOptions.PatientLinkOn = false;
    }


    // tracePlugin depends on spf registration, so we register immediately.
    spf.RegisterApplicationDefinitions( Services );
    
    // --------------------------
    // start bridge self-tests
    // Note: delay exit until end so that ALL failures can be reported/fixed
    var allSelfTestsPass = true;

    if ( false == BWContext.IsContextor || false == BWContext.IsConnected )
    {
        trace( "Error: no contextor or not connected to vault." );
        allSelfTestsPass = false;
    }

    if ( BridgeOptions.UserLinkOn && 0 == LogonSuccessSequences.length )
    {
        trace( "Error: Logon Success sequence(s) not are defined, but Single Sign-on (User Link) is enabled." );
        allSelfTestsPass = false;
    }

    if ( '' == BridgeOptions.ApplicationName )
    {
        trace( "Error: BridgeOptions.ApplicationName is not defined." );
        allSelfTestsPass = false;
    }

    if ( !allSelfTestsPass )
    {
        errorMessageBox(sprintf(sbmPlugin.getLocalizedString('TXT_WIZARD_BRIDGE__SELFTEST_FAILED', 
            "The %s bridge failed one or more self-tests. Check the trace log for details."), 
            BridgeOptions.ApplicationName),
                         true);

        BWSystem.ExitBridglet();
        return;
    }
    //
    // end bridge self-tests
    // ------------------------

    // check if bridge / app is already running
    if (CheckAlreadyRunning())
    {
        BWSystem.ExitBridglet();
        return;
    }

//  This code can be removed if the actions value input for WaitWindowTextChange supports regexp
/**/if (BridgeOptions.PatientLinkOn)
/**/{
/**/    var re = /\(.+\)/; // must find parens enclosing a non-empty string
/**/    if ( !re.test(BridgeOptions.ValidMRNRegexp) )
/**/    {
/**/        trace( "Error: BridgeOptions.ValidMRNRegexp syntax test failed");
/**/        allSelfTestsPass = false;
/**/    }
/**/}

    try
    {
        BWSystem.RegisterForLaunchpadActivate("OnLaunchPadActivate");
        BWSystem.RegisterForLaunchpadClose("OnLaunchPadClose");
    }
    catch(e)
    {
        trace("launchpad exception-" + e.description);
    }

    // complete initialization
    StartApplication();
    //$$exit, main
}

///////////////////////////////////////////////////////////////////////////
function errorMessageBox(msg, foreground)
{
    if ( undefined == foreground )
    {
        foreground = false;
    }
    BWSystem.ModalMessageBox(0,
                             msg,
                             BWSystem.BridgeName,
                             sbmPlugin.MessageType.Exclamation, 
                             sbmPlugin.ButtonType.Ok, 
                             foreground);
}

///////////////////////////////////////////////////////////////////////////
// checks if bridge / app is already running, check for agent mode
// return true to exit script, false if OK to run
function CheckAlreadyRunning()
{

   return sbmPlugin.CheckAlreadyRunning();
}

///////////////////////////////////////////////////////////////////////////
function StartApplication()
{
    trace();
    if ( BridgeOptions.BridgeLockEnabled )
    {
        // Unlike apps that are started interactively, BridgeWorks does not
        // start an app in the foreground. Some apps, however, grab 
        // foreground themselves upon startup.
        //
        // If an app grabs foreground during its startup, it may conflict
        // with other apps that *require* the foreground, for example, during
        // a context change.  Here we acquire the bridge lock for the benefit
        // of such other apps (which must also be run with bridge lock
        // enabled).

        // Acquire the bridge lock (with callback to OnAcquireBridgeLock).
        g_standardBridgeModel.AcquireBridgeLock(
            30000,                      /* wait time (ms) */
            30000,                      /* lock hold time */
            1000,                       /* timer interval */
            "CB_InputBlock Mutex",      /* lock name */
            true);                      /* use app callback */
    }
    else 
    {
        StartApplication2(); // immediately start the app
    }
}

///////////////////////////////////////////////////////////////////////////
function StartApplication2()
{
    // override code
    if (__override(null, 'StartApplication'))
    {
        return;
    }
    //$$entry, StartApplication, null 
    trace();

    // enable link status display
    g_standardBridgeModel.EnableDisplayLinkState(BridgeOptions.LinkStatusEnabled);

    spf.LaunchApplication( ApplicationLaunchArgMap );

    if ( BridgeOptions.UserLinkOn )
    {
        startSequences( WatchForApplicationStartSequences );
    }
    else 
    {
        trace ( "User Link (SSO) is disabled. Therefore, the bridge will not perform app automation. The bridge will generate audit events.")
    }
    //$$exit, StartApplication
}

///////////////////////////////////////////////////////////////////////////
//                                                                       //
//                      Derived Action Sequences                         //
//                                                                       //
///////////////////////////////////////////////////////////////////////////
//
// Here we refactor the code generated by the Wizard (action sequences and
// window/web defs) to construct the set of startup, driver/watcher, and 
// other action sequences that are used with the standard bridge model.
//
///////////////////////////////////////////////////////////////////////////
//              Driver-Watcher Pattern - User Context Support            //
///////////////////////////////////////////////////////////////////////////

var LoginDrivers = [];

var DriveThruLoginHeader =
    [detectAppStartFromSequence( Logon ),
     Actions.Custom({custom: function ()
                             {
                                 // override code
                                 if (__override(null, 'Login_Header'))
                                 {
                                     return;
                                 }
                                 //$$entry, Login_Header, null 
                                 trace("Drive Thru Login started - login screen found");
                                 setManagedWindowFromSequences( [Logon] );
                                 //$$exit, Login_Header
                             }
                   })
    ];
    
var DriveThruLoginFooter = 
    [Actions.Custom({custom: function () 
                             {  
                                 // override code
                                 if (__override(null, 'Login_Footer'))
                                 {
                                     return;
                                 }
                                 //$$entry, Login_Footer, null 
                                 trace("Drive Thru Login completed - starting outcome watchers"); 
                                 stopAllSequences();
                                 startSequences( DriveThruLoginOutcomeWatchers );
                                 //$$exit, Login_Footer
                             }
                   })
    ];

var DriveThruLogin = DriveThruLoginHeader.concat( Logon, DriveThruLoginFooter );
DriveThruLogin.seqname = 'DriveThruLogin';

LoginDrivers.push(DriveThruLogin);
///////////////////////////////////////////////////////////////////////////
// Login watchers

var LoginSuccessWatchers = [];

// DriveThruLoginOutcomeWatchers (list of sequences)
//
// * include all watchers for: Logon Success, Invalid Password, and Expired
//   Password.
//
// * are started within the footer of the Drive Thru Logon sequences (i.e.,
//   *after* all Logon steps have executed).
//
// * Do *not* include the login failsafe watchers (which must be started
//   at the beginning of the drive thru login process--i.e., conncurrently
//   with the start of the Logon sequences)
//
var DriveThruLoginOutcomeWatchers = [];

// DriveThruExpiredPasswordLoginOutcomeWatchers (list of sequences)
//
// * include all watchers for: Logon Success and Expired Password.
//
// * are started within the footer of Drive Thru Expired Password Logon
//   sequences.
//
// * Do *not* include the login failsafe watchers.
//
var DriveThruExpiredPasswordLoginOutcomeWatchers = [];

var WatchForLogonSuccess1Footer = 
    [Actions.Custom({custom: function () 
                             {  
                                 // override code
                                 if (__override(null, 'LogonSuccess1_Footer'))
                                 {
                                     return;
                                 }
                                 //$$entry, LogonSuccess1_Footer, null 
                                 trace("Login Succeeded"); 
                                 bStartup = false;
                                 stopAllSequences();
                                 setManagedWindowFromSequences( [].concat( LogoutSequences, LogonSuccessSequences ));
                                 if (BridgeOptions.moveToWorkArea) moveToWorkArea();
                                 g_standardBridgeModel.OnLoginSuccess();
                                 //$$exit, LogonSuccess1_Footer
                             }
                   })
    ];

var WatchForLogonSuccess1 = [].concat( LogonSuccess1, WatchForLogonSuccess1Footer );
WatchForLogonSuccess1.seqname = 'WatchForLogonSuccess1';

DriveThruLoginOutcomeWatchers.push(WatchForLogonSuccess1);
DriveThruExpiredPasswordLoginOutcomeWatchers.push(WatchForLogonSuccess1);
LoginSuccessWatchers.push(WatchForLogonSuccess1);
var WatchForLogonSuccess2Footer = 
    [Actions.Custom({custom: function () 
                             {  
                                 // override code
                                 if (__override(null, 'LogonSuccess2_Footer'))
                                 {
                                     return;
                                 }
                                 //$$entry, LogonSuccess2_Footer, null 
                                 trace("Login Succeeded"); 
                                 bStartup = false;
                                 stopAllSequences();
                                 setManagedWindowFromSequences( [].concat( LogoutSequences, LogonSuccessSequences ));
                                 if (BridgeOptions.moveToWorkArea) moveToWorkArea();
                                 g_standardBridgeModel.OnLoginSuccess();
                                 //$$exit, LogonSuccess2_Footer
                             }
                   })
    ];

var WatchForLogonSuccess2 = [].concat( LogonSuccess2, WatchForLogonSuccess2Footer );
WatchForLogonSuccess2.seqname = 'WatchForLogonSuccess2';

DriveThruLoginOutcomeWatchers.push(WatchForLogonSuccess2);
DriveThruExpiredPasswordLoginOutcomeWatchers.push(WatchForLogonSuccess2);
LoginSuccessWatchers.push(WatchForLogonSuccess2);
var WatchForLogonSuccess3Footer = 
    [Actions.Custom({custom: function () 
                             {  
                                 // override code
                                 if (__override(null, 'LogonSuccess3_Footer'))
                                 {
                                     return;
                                 }
                                 //$$entry, LogonSuccess3_Footer, null 
                                 trace("Login Succeeded"); 
                                 bStartup = false;
                                 stopAllSequences();
                                 setManagedWindowFromSequences( [].concat( LogoutSequences, LogonSuccessSequences ));
                                 if (BridgeOptions.moveToWorkArea) moveToWorkArea();
                                 g_standardBridgeModel.OnLoginSuccess();
                                 //$$exit, LogonSuccess3_Footer
                             }
                   })
    ];

var WatchForLogonSuccess3 = [].concat( LogonSuccess3, WatchForLogonSuccess3Footer );
WatchForLogonSuccess3.seqname = 'WatchForLogonSuccess3';

DriveThruLoginOutcomeWatchers.push(WatchForLogonSuccess3);
DriveThruExpiredPasswordLoginOutcomeWatchers.push(WatchForLogonSuccess3);
LoginSuccessWatchers.push(WatchForLogonSuccess3);
///////////////////////////////////////////////////////////////////////////
// Login failsafe timer watcher

var WatchForLoginFailsafe = 
    [Actions.Sleep(Property(BridgeOptions, 'LoginFailsafeDelay')),
     Actions.Custom({custom: function () 
                             {  
                                 trace("Login timed out"); 
                                 stopAllSequences();
                                 setManagedWindowFromSequences( [].concat( LogoutSequences, LogonSuccessSequences ));
                                 g_standardBridgeModel.OnLoginFail(sbmPlugin.VERGENCE_DIALOG_ACQUIRE_PASSWORD_PURPOSE.PASSWORD_USER_CHANGE);

                                
                                 var BRIDGE_CANT_LOG_INTO_APPLICATION = 0x800403F0;

                                 var strMessage = sprintf(sbmPlugin.getLocalizedString('TXT_WIZARD_BRIDGE__LOGIN_FAILED', 
                                                "The %s bridge could not automatically log you into the application. " +
                                                    "You may log in manually, and the Bridge will follow " +
                                                "the next user context change."),
                                                BWSystem.BridgeName);
                                 var strLog = strMessage;

                                 g_standardBridgeModel.LogMessage(BRIDGE_CANT_LOG_INTO_APPLICATION, 
                                                                    true,
                                                                    strMessage,
                                                                    strLog);                                 
                             }
                   })
    ];
WatchForLoginFailsafe.seqname = 'WatchForLoginFailsafe';

DriveThruLoginOutcomeWatchers.push(WatchForLoginFailsafe);
DriveThruExpiredPasswordLoginOutcomeWatchers.push(WatchForLoginFailsafe);

///////////////////////////////////////////////////////////////////////////
// Logout watchers - complete the logout state transition (multiples may exist)

var LogoutSuccessWatchers = [];
var LogoutOutcomeWatchers = [];
var LogoutSuccessThenTerminateWatchers = []; // serves a limited purpose
var LogoutOutcomeThenTerminateWatchers = []; // serves a limited purpose

                        
///////////////////////////////////////////////////////////////////////////
// Logout failsafe timer
//
// Note - logout failure is detected only through failsafe timer

var WatchForLogoutFailsafe = 
    [Actions.Sleep( Property(BridgeOptions, 'LogoutFailsafeDelay') ),
     Actions.Custom({custom: function () 
                             {  
                                 trace("Logout timed out"); 
                                 stopAllSequences();
                                 setManagedWindowFromSequences( [ LogoutSequences[0] ] );
                                 g_standardBridgeModel.OnLogoutFail();
                                 var BRIDGE_CANT_FOLLOW_USER_CONTEXT_CHANGE = 0x800403A0;

                                 var strMessage = sprintf(sbmPlugin.getLocalizedString('TXT_WIZARD_BRIDGE__LOGOUT_FAILED', 
                                     "The bridge '%s' cannot follow " +
                                     "a user context change (because logout failed). The application (and bridge) " +
                                     "will now close. Please restart the bridge."),
                                     BWSystem.BridgeName);
                                 var strLog = strMessage;

                                 g_standardBridgeModel.LogMessage(BRIDGE_CANT_FOLLOW_USER_CONTEXT_CHANGE, 
                                                                  false,
                                                                  strMessage,
                                                                  strLog);

                                 terminateTheApp(false);
                             }
                    })
    ];
WatchForLogoutFailsafe.seqname = 'WatchForLogoutFailsafe';

LogoutOutcomeWatchers.push(WatchForLogoutFailsafe);
LogoutOutcomeThenTerminateWatchers.push(WatchForLogoutFailsafe);
                        
///////////////////////////////////////////////////////////////////////////
// Invalid password login watcher(s)

var InvalidPasswordDismiss1Footer = 
    [Actions.Custom({custom: function () 
                             {  
                                 // override code
                                 if (__override(null, 'InvalidPasswordDismiss1_Footer'))
                                 {
                                     return;
                                 }
                                 //$$entry, InvalidPasswordDismiss1_Footer, null 
                                 trace("Login Failed - Invalid Password"); 
                                 bStartup = false;
                                 stopAllSequences();
                                 // if the user does a wait instead of a dismiss,
                                 // the we allow the PWL to parent the error.
                                 setManagedWindowFromSequences([].concat([ InvalidPasswordDismiss1 ], LoginDrivers) );
                                 // GUI needs to add selection for seq.failreason
                                 var failreason = sbmPlugin.VERGENCE_DIALOG_ACQUIRE_PASSWORD_PURPOSE.PASSWORD_INCORRECT;
                                 if (InvalidPasswordDismiss1.failreason)
                                 {
                                     failreason = InvalidPasswordDismiss1.failreason;
                                 }
                                 g_standardBridgeModel.OnLoginFail(failreason);
                                 //$$exit, InvalidPasswordDismiss1_Footer
                             }
                    })
    ];

var WatchForInvalidPasswordDismiss1 = [].concat( InvalidPasswordDismiss1, InvalidPasswordDismiss1Footer );
WatchForInvalidPasswordDismiss1.seqname = 'WatchForInvalidPasswordDismiss1';

DriveThruLoginOutcomeWatchers.push(WatchForInvalidPasswordDismiss1);
var InvalidPasswordDismiss2Footer = 
    [Actions.Custom({custom: function () 
                             {  
                                 // override code
                                 if (__override(null, 'InvalidPasswordDismiss2_Footer'))
                                 {
                                     return;
                                 }
                                 //$$entry, InvalidPasswordDismiss2_Footer, null 
                                 trace("Login Failed - Invalid Password"); 
                                 bStartup = false;
                                 stopAllSequences();
                                 // if the user does a wait instead of a dismiss,
                                 // the we allow the PWL to parent the error.
                                 setManagedWindowFromSequences([].concat([ InvalidPasswordDismiss2 ], LoginDrivers) );
                                 // GUI needs to add selection for seq.failreason
                                 var failreason = sbmPlugin.VERGENCE_DIALOG_ACQUIRE_PASSWORD_PURPOSE.PASSWORD_INCORRECT;
                                 if (InvalidPasswordDismiss2.failreason)
                                 {
                                     failreason = InvalidPasswordDismiss2.failreason;
                                 }
                                 g_standardBridgeModel.OnLoginFail(failreason);
                                 //$$exit, InvalidPasswordDismiss2_Footer
                             }
                    })
    ];

var WatchForInvalidPasswordDismiss2 = [].concat( InvalidPasswordDismiss2, InvalidPasswordDismiss2Footer );
WatchForInvalidPasswordDismiss2.seqname = 'WatchForInvalidPasswordDismiss2';

DriveThruLoginOutcomeWatchers.push(WatchForInvalidPasswordDismiss2);
///////////////////////////////////////////////////////////////////////////
// Reauthentication automation (watcher-driver) sequence(s)

var ReauthenticationWatcherDrivers = [];

///////////////////////////////////////////////////////////////////////////
// Expired password login driver(s)

// The expired password login driver is determined at run time by the
// corresponding expired password login watcher (see
// DriveThruExpiredPasswordLogin below).

var DriveThruExpiredPasswordLoginSequences = [];
var DriveThruChangePasswordLoginSequences = [];
var DriveThruExpiredPasswordLogin; // set by corresponding watcher

///////////////////////////////////////////////////////////////////////////
// Expired password login watcher(s)

///////////////////////////////////////////////////////////////////////////
//            Driver-Watcher Pattern - Patient Context Support           //
///////////////////////////////////////////////////////////////////////////

var ClearPatientDrivers = [];
var FollowPatientDrivers = [];
var PatientSetWatchers = [];

 // end Patient Context Support

///////////////////////////////////////////////////////////////////////////
//      Driver-Watcher Pattern - Custom (Named) Sequences Support        //
///////////////////////////////////////////////////////////////////////////

var CustomDrivers = [];

///////////////////////////////////////////////////////////////////////////
//         Driver-Watcher Pattern - Startup/Shutdown Support             //
///////////////////////////////////////////////////////////////////////////

// Note - watchers do not continue running and need to be restarted to detect 
// app restart.

// Watcher for the initial application startup
var WatchForApplicationStartSequences = [];

var WatchForApplicationStartLogon = 
[
    detectAppStartFromSequence( LoginDrivers[0] ),
    Actions.Custom({custom: function () { handleAppStartupSuccess( LoginDrivers[0] ); } })
];
WatchForApplicationStartLogon.seqname = 'WatchForApplicationStartLogon';
WatchForApplicationStartSequences.push(WatchForApplicationStartLogon)
var WatchForApplicationExit = 
[
// TODO
];
WatchForApplicationExit.seqname = 'WatchForApplicationExit';

///////////////////////////////////////////////////////////////////////////
//           Driver-Watcher Pattern - AutoMinimize Support               //
///////////////////////////////////////////////////////////////////////////
var RestoreAppWatcher = 
[ 
  Actions.WaitEx({
      windowdef:$F('RestoreAppWatcherWaitWindowdef'), 
              waitoption:"WaitWindow",
              waitWindowState:"WaitWindowMinimized"
       })
  ,
  Actions.WaitEx({
       windowdef:$F('RestoreAppWatcherWaitWindowdef'), 
              waitoption:"WaitWindow",
              waitWindowState:"WaitWindowRestored"
       })
  ,
  // app has just transitioned from 'minimized' to 'restored'
  Actions.Custom({
    custom: function ()
            {
                if ( bPatientChangeDelayed )
                {
                    trace("Patient context change was delayed - restarting it now");

                    // We must clear the patient upon restoration, but the model
                    // has a bug: onClearSubjectFail incorrectly goes to SS_CLEAR; 
                    // therefore, here we force the model to SS_SET.
                    g_standardPatientModel.SetSubjectState(g_standardPatientModel.SS_SET);

                    // We defer the following assignment until AFTER we have signalled
                    // SS_SET - this ensures that we don't restart the patient set 
                    // watcher too soon (i.e., prior to clearing to patient from the app).
                    bPatientChangeDelayed = false;

                    // force a context change
                    g_standardPatientModel.m_strContextSubject = "$$$NOT_A_PATIENT$$$";
                    g_standardBridgeModel.OnReadyForChange();
                }
                startSequences( [ RestoreAppWatcher ] ); // restart the watcher
            }
      })
  ];

RestoreAppWatcher.seqname = 'RestoreAppWatcher';

var bPatientChangeDelayed = false;
var bAutoMinimizeStrategy = BridgeOptions.AutoMinimizeOnClearPatient || BridgeOptions.AutoMinimizeOnPatientSearch;

///////////////////////////////////////////////////////////////////////////
// always except these sequences when stopping
///////////////////////////////////////////////////////////////////////////

var alwaysExceptSequences = [WatchForApplicationExit];

///////////////////////////////////////////////////////////////////////////
//                Utility - Helper Functions                             //
///////////////////////////////////////////////////////////////////////////
function moveToWorkArea()
{
    try
    {
        var hWnd = getManagedWindow();
        if (hWnd)
        {
            var windowRef = BWWin32.WindowWithId(hWnd);

            if (!windowRef.insideWorkArea)
            {
                windowRef.moveToWorkArea();
            }
        }
    }
    catch(e)
    {
        trace("exception-"+e.description);
    }
}

///////////////////////////////////////////////////////////////////////////
//                Driver-Watcher Pattern - Helper Functions              //
///////////////////////////////////////////////////////////////////////////
function stopSequences(sequences)
{
    //trace();
    if (null == sequences)
    {
        trace("no sequences provided");
        return;
    }
    for (var i in sequences) 
    {
        var seq = sequences[i];
        if ( 'string' != (typeof seq.seqname) )
        {
            trace('undefined seqname in ' + traceToString(seq));
            return;
        }

        trace("Stopping sequence " + seq.seqname);
        Actions.StopExecutionGroup( seq.seqname, Execute.OnStopInternal );
    }
}

function stopAllSequencesExcept(exceptSequences)
{
    function seq2seqname(seq) 
    { 
        if ( 'string' != (typeof seq.seqname) )
        {
            trace('undefined seqname in ' + traceToString(seq));
            return;
        }
        return seq.seqname; 
    }
    var exceptNames = map( seq2seqname, exceptSequences );
    var exceptNames2 = map( seq2seqname, alwaysExceptSequences );
    exceptNames = exceptNames.concat ( exceptNames2 );
    Actions.StopAllExecutionGroupsExcept( exceptNames, Execute.OnStopInternal );
}

function stopAllSequences()
{
    stopAllSequencesExcept( [] );
}

///////////////////////////////////////////////////////////////////////////
function startSequences(sequences)
{
    //trace();
    if (null == sequences)
    {
        trace("no sequences provided");
        return;
    }
    stopSequences(sequences);  // if sequences already running, must stop them first.
    for (var i in sequences) 
    {
        var seq = sequences[i];
        if ( 'string' != (typeof seq.seqname) )
        {
            trace('undefined seqname in ' + traceToString(seq));
            return;
        }

        trace("Starting sequence " + seq.seqname);
        Actions.Execute( seq, seq.seqname );  // (re)start the sequence.
    }
}

///////////////////////////////////////////////////////////////////////////
// Windowdef/Webdef/Wxdef/Window related helper functions
// 
// Definition: a "wxdef" object is either a windowdef or a webdef (we do not
// always care which).
//
// To aid in distinguishing them later, we "stamp" all returned wxdef objects
// with their discovered type (i.e., we inject them with the "wxtype"
// property).


// Returns the first wxdef of a sequence, or null if none found.
// 
// If optional wxtype is supplied, return only a wxdef of the 
// indicated type ('windowdef' or 'webdef').
//
// Effects: injects the wxtype into the returned object (i.e., 
// sets the object's wxtype property, to 'windowdef' or 'webdef').
function getFirstWxdefFromSequence(sequence, setmanagedwnd, wxtype)
{ 
    if (null == sequence)
    {
        trace("no sequence provided");
        return;
    }
    if ( 'string' != (typeof sequence.seqname) )
    {
        trace("undefined seqname in " + traceToString(sequence));
        return;
    }
    var wxdef, wxfound;
    
    if(setmanagedwnd == true)
    {
        //first find any wxdef, in a waitwindow action that is used to set the managed window
        for (var i in sequence) 
        {
            if ( !sequence[i].request )
            {
                continue;
            }
            if (sequence[i].request.ignore)
            {
                continue;
            }
            try
            {
                if(sequence[i].request.managedwindow != undefined)
                {
                    trace("found action to set managed window");

                    if(sequence[i].request.managedwindow == true)
                    {
                        if ( undefined != wxtype )
                        {
                          // find a wxdef of the requested type only
                         wxdef = sequence[i].request[wxtype];
                          if ( undefined != wxdef )
                          {
                               wxfound = wxtype;
                           }
                       }
                       else
                        {
                            // we don't care which type we find first
                            wxdef = sequence[i].request['windowdef'];
                            if ( undefined != wxdef )
                            {
                                wxfound = 'windowdef';
                            }
                            else
                            {
                                wxdef = sequence[i].request['webdef'];
                                if ( undefined != wxdef )
                                    wxfound = 'webdef';
                            }
                        }
                        if ( wxdef )
                        {
                            trace("found " + wxfound + " for " + sequence.seqname + " at index=", i);
                            wxdef.wxtype = wxfound; // inject the type for later use
                            return wxdef;
                        }   
                    }         
                }
            }
            catch(e)    
            {
                trace("Exception - " + e.description);
            }
        }    
    }
    
    for (var i in sequence) 
    {
        if ( !sequence[i].request )
        {
            continue;
        }
        if (sequence[i].request.ignore)
        {
            continue;
        }

        if ( undefined != wxtype )
        {
            // find a wxdef of the requested type only
            wxdef = sequence[i].request[wxtype];
            if ( undefined != wxdef )
            {
                wxfound = wxtype;
            }
        }
        else
        {
            // we don't care which type we find first
            wxdef = sequence[i].request['windowdef'];
            if ( undefined != wxdef )
            {
                wxfound = 'windowdef';
            }
            else
            {
                wxdef = sequence[i].request['webdef'];
                if ( undefined != wxdef )
                    wxfound = 'webdef';
            }
        }
        if ( wxdef )
        {
            trace("found " + wxfound + " for " + sequence.seqname + " at index=", i);
            wxdef.wxtype = wxfound; // inject the type for later use
            return wxdef;
        }
    }
    trace("no wxdef found");
    return null;
}

///////////////////////////////////////////////////////////////////////////
function getFirstWindowDefFromSequence(sequence)
{
    return getFirstWxdefFromSequence(sequence, 'windowdef', false);
}

///////////////////////////////////////////////////////////////////////////
function getFirstWebDefFromSequence(sequence)
{
    return getFirstWxdefFromSequence(sequence, 'webdef', false);
}

///////////////////////////////////////////////////////////////////////////
// Return the window of the first wxdef of sequence, or null
// if none found.
function getFirstWindowFromSequence(sequence, setmanagedwnd)
{
    var wxdef = getFirstWxdefFromSequence( sequence, true );

    if ( !wxdef ) 
    {
        return null; // neither windowdef nor webdef found
    }

    if ( 'windowdef' == wxdef.wxtype )
    {
        return getWindowFromWindowDef( wxdef );
    }
    else if ( 'webdef' == wxdef.wxtype )
    {
        var browser = Actions.LocateWebBrowser( wxdef );
        if ( browser )
        {
            return BWWin32.WindowWithId(browser.Window);
        }
    }
    else 
    {
        trace("error: wxdef is of unrecognized type");
    }
    return null;
}
 
///////////////////////////////////////////////////////////////////////////
// Returns the window of windowdef, or null if none.
// 
// Note: the spf process tracker ensures that the window returned 
// belongs to our app (if the app is running).
function getWindowFromWindowDef(windowdef)
{
    //trace();
    if ( null == windowdef )
    {
        return null;
    }

    // use actions to locate if not already found
    return Actions.LocateWindow(windowdef);
}

///////////////////////////////////////////////////////////////////////////
// get screen dims, primary
function GetScreenSize()
{
    var rect = {width: 0, height: 0};
    var wndDesktop = 0;
    var strComputer = ".";
    var objWMIService, colItems, e;
    try
    {
        try
        {
            wndDesktop = BWWin32.FindDesktopWindow();
        }
        catch(e)
        {
            wndDesktop = 0;
        }
        trace("after search for window");

        if(wndDesktop == 0 )
        {
            //continue to get screen size using WMI, if we cannot get the desktop window
            trace("No desktop found window");
            objWMIService = GetObject("winMgmts:{impersonationLevel=impersonate}!//" + strComputer + "/root/cimv2");
            trace("getscreensize1");
            colItems = objWMIService.InstancesOf("Win32_VideoController");
            trace("getscreensize2");
            e = new Enumerator(colItems);
            trace("getscreensize3");

            for(; !e.atEnd(); e.moveNext()) 
            {
                var objItem = e.item();    

                trace ("Name: " + objItem.Description);

                if(objItem.CurrentNumberOfColors == null)
                {
                    trace ("Failed to get values from video adpater");
                    rect.width = 0;
                    rect.height = 0;
                }
                else
                {
                    trace ("Color depth: " + objItem.CurrentNumberOfColors);
                    rect.width = objItem.CurrentHorizontalResolution;
                    trace ("rect.width =  " + rect.width);

                    rect.height = objItem.CurrentVerticalResolution;
                    trace ("rect.height =  " + rect.height);
                    break;
                }
            }
        }
        else
        {
            trace("Desktop found window");
            var width = wndDesktop.width;
            rect.width = width;
            trace ("screenrect.width: " + width);

            var height = wndDesktop.height;
            rect.height = height;
            trace ("screenrect.Height: " + height);
        }
    }
    catch (e)
    {
        WScript.Echo ("Exception: " + e.description);
    }

    // return it    
    return rect;
}

///////////////////////////////////////////////////////////////////////////
// general function to safely determine if a top-level window is displayed
function isWindowDisplayed(window)
{
    try
    {
        // first try new BridgeWorks method to determine if
        // window is displayed
        // Parameters: window, 
        // include minimized window = true,
        // include off screen window, 
        // include zero size window
        if (BWWin32.IsDisplayed(window, 
                                true, 
                                Bridge.BridgeOptions.AutoCloseOffScreen, 
                                Bridge.BridgeOptions.AutoCloseZeroSize))
        {
            trace ("Window is displayed: " + window);
            return true;
        }
        else
        {
            trace ("Window is NOT displayed: " + window);
            return false;
        }
    }
    catch (e)
    {
        // either we passed a bad window or we have an old version of
        // BW that does not support IsDisplayed.  Try old method.
        trace("Call to BWWin32.IsDisplayed failed. Exception: " + e.description);
    }

    try 
    {
        var hidden = BWWin32.IsHidden(window);
        if (!hidden)
        {
            if (window)
            {
                if (!Bridge.BridgeOptions.AutoCloseZeroSize)
                {
                    if ((window.width <= 0) || (window.height <= 0))
                    {
                        trace ("Zero size w="+window);
                        hidden = true;
                    }
                }
                if (!Bridge.BridgeOptions.AutoCloseOffScreen)
                {
                    t = window.top;
                    l = window.left;
                    // when minimized, top/left are off by 32000
                    if (window.minimized)
                    {
                        t += 32000;
                        l += 32000;
                    }
                    // get screen width/height
                    r = GetScreenSize();
                    // are we on there?
                    if ((t + window.height < 0) ||
                        (l + window.width < 0) ||
                        (t > r.height) ||
                        (l > r.width) )
                    {
                        trace ("Off Screen w="+window);
                        hidden = true;
                    }
                }
            }
        }
    }
    catch (e) 
    {
        trace ("Exception: "+e.description);
        return false; // invalid window handle
    }
    return !hidden;
}
    
///////////////////////////////////////////////////////////////////////////
// General function to determine if a window owns a displayed window.
// 
// Returns true if any owned window is displayed, false otherwise.
function isOwnedWindowDisplayed(owner)
{
    var ows = owner.ownedWindows;
    for ( var i in ows )
        if ( isWindowDisplayed( ows[i] ) || isOwnedWindowDisplayed( ows[i] ))
            return true;
    return false;
}
    
///////////////////////////////////////////////////////////////////////////
// general function to safely determine if a UI object (window or control) is enabled
function isUIObjectEnabled(obj)
{
    try 
    {
        var enabled = BWWin32.IsEnabled(obj); // see if this is a Win32 object
        return enabled;
    }
    catch (e) 
    {
       try 
       {
          var enabled = obj.enabled; // see if this is a UI Automation object
          return enabled;
       }
       catch (e) {}
    }
    return false; // invalid obj
}
    
///////////////////////////////////////////////////////////////////////////
// isAnyAppWindowDisplayed() - returns true if any application window is displayed,
// false otherwise.
//
// Note: for win32 this test may not be selective enough (it might match
// windows of other apps). If so, reimplement it as a custom function.
function isAnyAppWindowDisplayed()
{
    for (var i in Windows)
    {
        if ( isWindowDisplayed( getWindowFromWindowDef( Windows[i] )))
        {
            return true;
        }
    }
    for (var i in Pages)
    { 
        var browser = null;
        browser = Actions.LocateWebBrowser( Pages[i] );
        if ( null != browser)
        {
            if (browser.Native.GetProperty("Caradigm_IsBridged"))
            {
                trace("The browser instance is bridged");
                continue;
            }
            return true;
        }
    }
    return false;
}

///////////////////////////////////////////////////////////////////////////
// check is any app window is in foreground, based on managed process list
function isAnyAppWindowInForeground()
{
    //find pid
    var pid = 0;
    var hActive = 0;
    var procActive = 0;
    // save PID...
    try
    {
        hActive = BWWin32.FindActiveWindow();
        procActive = BWWin32.GetProcess(hActive);
        trace ("Active h,pid = " + hActive + "," + procActive); 
    }
    catch (e)
    {
        trace ("Bad process id "+procActive);
        procActive = 0;
    }

    // check if it is a window that is part of the managed processes
    if (0 != procActive)
    {
        for ( var p in spf.TrackProcesses.ProcessList )
        {
            var processdata = spf.TrackProcesses.ProcessList[ p ];
            if ( !processdata.active )
                continue;

            // see if valid process
            pid = processdata.pid;
            var procinfo = BWProcess.ProcessWithId( pid );
            if ( procinfo )
            {
                try
                {
                    trace( 'TextOut process:', pid, procinfo.name );
                }
                catch( e ) { /* ok to ignore exception */ }
            }
            if (procActive.PID == pid)
            {
                trace ("IS in foreground");
                return true;
            }
        }
    }

    return false;
} 

///////////////////////////////////////////////////////////////////////////
// Return the current managed window of the app.
// 
// The managed window is a single important toplevel application window
// (typically the app's main window or login dialog window).
function getManagedWindow()
{
    return sbmPlugin.oManagedContainerTracker.getWindowId();
}

///////////////////////////////////////////////////////////////////////////
// Return the managed browser of the app.
function getManagedBrowser()
{
    return sbmPlugin.oManagedContainerTracker.getBrowser();
}

///////////////////////////////////////////////////////////////////////////
// Set the current managed (toplevel) window of the app.  Loop through the
// array of sequences looking for a window object; set the first one found.
function setManagedWindowFromSequences(sequences)
{
    trace(); 
    // try sequences in order until a valid wnd is found
    for (var i in sequences)
    {
        var wnd = getFirstWindowFromSequence( sequences[i], true );
        if ( wnd )
        {
            sbmPlugin.oManagedContainerTracker.setWindowId( wnd );
            return;
        }
    }
}

///////////////////////////////////////////////////////////////////////////
// Set the managed browser of the app.  Loop through the array of sequences
// looking for a browser object; set the first one found.
function setManagedBrowserFromSequences(sequences)
{
    trace(); 
    var seq;
    var step;
    var control;
    var browser;
    // try sequences in order until a valid browser is found
    for (var i in sequences)
    {
        seq = sequences[i];
        for ( var j in seq )
        {
            step = seq[j];
            if ( step.request && step.request['webdef'] )
            {
                browser = Actions.LocateWebBrowser( step.request['webdef'] );
                if ( browser )
                {
                    sbmPlugin.oManagedContainerTracker.setBrowser( browser );
                    return;
                }
            }
            else if ( step.request && step.request['windowdef'] )
            {
                control = Actions.GetWindowsControl( step.request );
                // Search the win32 control hierarchy for an embedded browser
                // object (supports web-in-win32).
                while ( control )
                {
                    if ( control.browser )
                    {
                        trace("setting managed browser from step=", step.request);
                        sbmPlugin.oManagedContainerTracker.setBrowser( control.browser );
                        return;
                    }
                    control = control.parent;
                }
            }
            else 
                trace("Error: unknown request type for step=", step.request);
        }
    }
}

///////////////////////////////////////////////////////////////////////////
function getHWNDFromWnd (wnd)
{
    try 
    {
        return wnd.HWND;
    }
    catch (e)
    {
        return null;
    }
}

///////////////////////////////////////////////////////////////////////////
// Convenient function for closing all dialogs from a custom.
// Simply add a custom step and specify CloseAllDialogsFromCustom
// as the function
function CloseAllDialogsFromCustom( request, callback_oncompleted )
{
    // signal intends to block
    this.SetBlocking();

    // initiate the close all dialogs
    CloseAllDialogsCPS(true,
                       function () // the continuation, complete the action
                       {
                            // now done
                            callback_oncompleted(Action.Success);
                       });
    // warning: Close Dialog sequences do not execute until we return
    return;
}

///////////////////////////////////////////////////////////////////////////
// Old style special close script like we used to have.
// Return true if you handle the close or skip closing, 
// return false to continue with automatic closing.
function CloseAllDialogsSpecial( wnd )
{
    //$$entry, CloseAllDialogsSpecial(wnd), null 
    // Old style special close script like we used to have.
    // Return true if you handle the close or skip closing, 
    // return false to continue with automatic closing.
    return false;
    //$$exit, CloseAllDialogsSpecial 
}

///////////////////////////////////////////////////////////////////////////
//
// CloseAllDialogsCPS
// 
// Gracefully closes each visible:
// 
//    1. toplevel window 'owned' by a managed window.  A Win32 app has 
//       one managed window; a Web app has one or more managed windows 
//       (i.e., one or more browers).
//
//    2. toplevel window that is a 'peer' of a managed window (i.e.,
//       that shares the process ID of the managed window or that belongs
//       to a child process of same).
//
//    3. window (either toplevel or child) that has a Close Dialog 
//       sequence defined for it
//
// * Processes 'active' toplevel windows first (a window is active if it does
//   not own another window).
//
// * Schedules eligible 'Close Dialog' action sequences as needed.
//
// * Uses 'Continuation Passing Style' (CPS) to correctly serialize action
//   sequence execution, and to synchronize with the caller's continuation.
//
//   (A continuation is simply a function of no arguments that represents 
//   "the rest of the caller's computation"--see notes below.)
//
// Arguments:
//
// bCloseBWDialogs - if true, first close BW-generated dialogs, if any.
//
// oncompletion - the continuation of the caller; oncompletion is a function 
//                of no args.
//
// bGracefully - if true, use both Close Dialogs sequences and smart/hard closing.
//             - if false, use smart/hard closing only; do not start sequences.
//
// Notes: 
//
// * This strategy is sufficient to close menu dialogs, popups, and additional
//   web browser windows, if any, based on either window ownership or process
//   ownership.
// 
//   Currently, this strategy is not sufficient to close non-owned app windows
//   that belong to unrelated processes (e.g., a PDF document browser).
//
// * To exclude a toplevel from sequence-directed closing, define a no-op Close Dialog
//   sequence for it.
//
// * To be scheduled to run, the first window or page of a Close Dialog sequence
//   must "match" the candidate toplevel:
// 
//     1. the child control of the first window or page (or the toplevel itself if there 
//        is no child control) must be enabled.  
//     2. the sequence must not have been scheduled previously for the candidate
//        toplevel in this call to CloseAllDialogsCPS (to prevent infinite loops 
//        if the sequence fails to close the toplevel 
//        (see sequenceWindowPairingsAlreadyTried).
//
// * BW and Actions normally return Window objects, not Window handles (true
//   hWnds).
//
// * Some windows cannot be closed.  Therefore, we try to close windows only
//   once (via the wndsAlreadyTried and sequenceWindowPairingsAlreadyTried lists).
//
// * "Peer" windows are unowned toplevels that share the process ID of the
//   managed window, or that belong to a child process of the managed window.
//
// * For a Win32 bridge, peers may be handled by either Close Dialogs sequences or 
//   by smart and hard closing.  The managed window is excluded from smart and 
//   hard closing.
//
// * For a Web bridge, multiple browser toplevels may be handled by Close Dialogs
//   sequences, but the browser toplevels and most of their peers are excluded from
//   both smart and hard closing (as peers may belong to other apps). (New in V6.)
//
// * The implementation exploits JavaScript's lexical scoping rules for local
//   variables.  Specifically, the internally defined functions of
//   CloseAllDialogsCPS (getNextWindowToClose, etc.) are *within* the
//   lexical scope of its local variables (managedWnd, etc.).
//
// * Proper use of continuation passing style: when passed a continuation, it
//   is the callee's responsibility either to invoke the continuation
//   directly or to pass it to another function for invocation later.

///////////////////////////////////////////////////////////////////////////

function CloseAllDialogsCPS( bCloseBWDialogs, oncompletion, bGracefully )
{
    trace();

    if ( bGracefully == undefined )
        bGracefully = true;

    trace("Close Dialogs sequences are ", ((bGracefully) ? "enabled" : "disabled"));

    var isWebApp = (ApplicationLaunchArgMap.AppType == AppLaunch.isWebApplication);

    // Windows that have already been tried during this call.
    var wndsAlreadyTried = [];

    // Close Dialogs sequence-window pairings that have been tried during this call 
    // (we try each pairing only once to prevent infinite loops).
    var sequenceWindowPairingsAlreadyTried = []; 

    for (var i in CloseAllDialogsWindowDefExclusionsList)
    {
        var wnd = getWindowFromWindowDef( CloseAllDialogsWindowDefExclusionsList[i] );
        if (wnd)
        {
            trace("Excluding window: ", CloseAllDialogsWindowDefExclusionsList[i], wnd.HWND);
            wndsAlreadyTried.push(wnd);
        }
    }
    // getNextWindowToClose()
    //
    // Find a candidate window to close, using either window ownership or peer relationship
    // (process ID match).
    //
    // Returns a type-tagged candidate: { wnd: <wnd>, type: "peer" | "owned" }
    // or null if no candidate found.
    function getNextWindowToClose(toplevel)
    {
        // Return an active application window that is owned by wndOwner and
        // has not been tried. If none are found, return wndOwner.
        //
        // Note: in Win32 the owner-owned relationship is separate from the
        // parent-child relationship (e.g., an owned window may belong to
        // a separate process).
        function getUntriedOwnedWindow(wndOwner)
        {
            var ownedWnds = wndOwner.ownedWindows;
            for ( var i = 0; i < ownedWnds.length; i++ )
            {
                if ( !isMemberOf( ownedWnds.Item(i), wndsAlreadyTried ))
                    return getUntriedOwnedWindow( ownedWnds.Item(i) );

            }
            return wndOwner;  // owner owns no untried windows
        }
        var candidate;
        try
        {
            candidate = getUntriedOwnedWindow( toplevel );
        }
        catch (e)
        {
            candidate = toplevel;
        }

        if ( candidate != toplevel )
        {
            trace("returning owned window:", getHWNDFromWnd(candidate));
            return { wnd: candidate, type: "owned" };
        }
        // no untried owned window; look for an untried "peer" window (i.e., with the process ID 
        // of the toplevel window or that belongs to a child process of same).
        var peers;
        try
        {
            var process  = toplevel.processId;  // a BW process object
            var my_peers = BWWin32.FindApplicationWindows("*", "*", process.PID).toArray();
            var all_peers = [];
            if ( process.children )
                all_peers = map( function (child) { return BWWin32.FindApplicationWindows("*", "*", child.PID).toArray(); }, process.children.toArray() );
            all_peers.push(my_peers);
            peers = flatten(all_peers);     
        }
        catch (e)
        {
            trace("caught exception accessing process of toplevel: ", getHWNDFromWnd(toplevel), " - setting toplevel's peers to the empty list");
            peers = [];
        }

        for (var i in peers)
        {
            candidate = peers[i];
            if ( toplevel != candidate &&
                 !isMemberOf( candidate, wndsAlreadyTried ) &&
                 isWindowDisplayed( candidate ) &&
                 !isOwnedWindowDisplayed( candidate )
                )
            {
                trace("returning peer window:", getHWNDFromWnd(candidate));
                return { wnd: candidate, type: "peer" };
            }
        }
        if ( !isMemberOf( toplevel, wndsAlreadyTried ))
        {
            trace("found no other window to close - returning the toplevel: ", getHWNDFromWnd(toplevel));
            return { wnd: toplevel, type: "peer" };
        }
        else
        {
            trace("found no window to close");
            return null;
        }
    }

    function hardClose(wnd)
    {
        trace("wnd.HWND=", getHWNDFromWnd(wnd));
        try
        {
            // is this a browser window?
            var browser = BWWeb.Browsers.Filter(wnd).item(0);
            browser.Close();
        }
        catch (e)
        {
            try
            {
                BWWin32.Close(wnd);
            }
            catch (e)
            {
                trace ("BWWin32.Close failed");
            }
        }
    }

    // return the first untried close dialogs sequence matching the eligible window, or
    // null if none.
    function getCloseDialogsSequenceForEligibleWindow(eligible_wnd)
    {
        //
        // isSequenceWindowPairingAlreadyTried()
        //
        function isSequenceWindowPairingAlreadyTried(sw_pairing)
        {
            for (var i = 0; i < sequenceWindowPairingsAlreadyTried.length; i++)
            {
                var already_tried = sequenceWindowPairingsAlreadyTried[i];
                if ( sw_pairing.seq == already_tried.seq && 
                     sw_pairing.wnd == already_tried.wnd )
                {
                    return true;
                }
            }
            return false;
        }
        //
        // isSequenceEligibleToRun()
        //
        // Returns true if sequence:
        //   1. has not yet been tried for the eligible window
        //   2. first Windef/Webdef of sequence references a UI object 
        //      (either toplevel or control) that is enabled
        //
        // Note: at this point we have already determined that the Action's associated 
        // toplevel, eligible_wnd, is both enabled and displayed.
        //
        function isSequenceEligibleToRun( seq )
        {
            if ( isSequenceWindowPairingAlreadyTried( { seq: seq, wnd: eligible_wnd } ))
            {
                trace("For Close Dialogs sequence=" + seq.seqname + " sequence has already been tried for this window; therefore, sequence is ineligible");
                return false;
            }
            var action = seq[0];
            var ui_obj = Actions.GetWindowsControl( action.request );
            if ( undefined == ui_obj || null == ui_obj )
            {
                trace("For Close Dialogs sequence=" + seq.seqname + " Actions.GetWindowsControl returned UI object=" + ui_obj + "; therefore, sequence is ineligible");
                return false;
            }
            if ( isUIObjectEnabled(ui_obj) )
            {
                trace("Found eligible Close Dialogs sequence=" + seq.seqname + " for enabled UI object=" + ui_obj, " HWND=", getHWNDFromWnd(ui_obj));
                return true;
            }
            trace("For Close Dialogs sequence=" + seq.seqname + " UI object=" + ui_obj, " HWND=", getHWNDFromWnd(ui_obj) + " is disabled; therefore sequence is ineligible");
            return false;
        }

        if ( !bGracefully )
            return null; // Close Dialogs sequences are disabled.
  
        for (var i = 0; i < CloseDialogsSequences.length; i++)
        {
            var seq = CloseDialogsSequences[i];
            var wxdef = getFirstWxdefFromSequence( seq, false );
            if ( ('windowdef' == wxdef.wxtype) &&
                 ( eligible_wnd == getWindowFromWindowDef( wxdef )) &&
                 isSequenceEligibleToRun( seq ) )
            {
                return seq;
            }
        }
        return null;
    }

    // candidate is a type-tagged window: { wnd: <wnd>, type: "peer" | "owned" }
    function processCandidateForClosing( toplevel, candidate, oncompletion )
    {
        var wnd = candidate.wnd;
        var wnd_text = "[not available]";
        var wnd_className = "[not available]";
        try 
        {
            wnd_className = wnd.className;
            wnd_text = wnd.text;
        } 
        catch (e) { }

        trace("candidate HWND=", getHWNDFromWnd(wnd),
              "candidate type=", candidate.type,
              "wnd.className=", wnd_className,
              "wnd.text=", wnd_text,
              "wndsAlreadyTried=", map( getHWNDFromWnd, wndsAlreadyTried ));

        if (CloseAllDialogsSpecial(wnd))
        {
            trace("this window was handled by Special custom handler");
            wndsAlreadyTried.push( wnd );
            oncompletion(); return; // invoke caller's continuation & return
        }
        if ( !isWindowDisplayed( wnd ))
        {
            trace("this window is NOT eligible for closing: it is not displayed");
            wndsAlreadyTried.push( wnd );
            oncompletion(); return; // invoke caller's continuation & return
        }
        if ( !isUIObjectEnabled( wnd ))
        {
            trace("this window is NOT eligible for closing: it is not enabled");
            wndsAlreadyTried.push( wnd );
            oncompletion(); return; // invoke caller's continuation & return
        }
        trace("this window is eligible for closing - finding a close dialog sequence...");
        var closeSeq = getCloseDialogsSequenceForEligibleWindow( wnd );
        if ( closeSeq )
        {
            trace ("Starting eligible Close Dialog sequence=", closeSeq.seqname);

            // We have found a matching close dialog sequence; append the
            // continuation step (kStep) and start the sequence now.

            // kStep represents the continuation of this activation of
            // CloseAllDialogsCPS.  kStep effectively restarts this invocation of
            // CloseAllDialogsCPS after all steps of closeSeq are complete.
            var kStep = Actions.Custom({ custom: function ()
                        {
                        trace("kStep: end of Close Dialogs sequence for wnd.HWND=", getHWNDFromWnd(wnd));
                        oncompletion(); return; // invoke caller's continuation & return
                        }
                    });
            var CADCloser = [].concat( closeSeq, kStep );
            CADCloser.seqname = closeSeq.seqname + "_CloseAllDialogsCPS";

            startSequences( [ CADCloser ] );
            sequenceWindowPairingsAlreadyTried.push( { seq: closeSeq, wnd: wnd } );
            return; // must return now to allow CADCloser to run immediately
        }
        else
        {
            trace ("did NOT find an eligible Close Dialogs sequence");
        }

        // The toplevel is a candidate for close dialog sequences, but is excluded
        // from both smart and hard closing.
        if ( wnd != toplevel )
        {
            // Peer candidates are eligible for close dialog sequences, but in webapps are mostly
            // ineligible for smart or hard closing (because they might belong to another app).
            // (certain IE dialog frames are an allowed exception.)
            if ( isWebApp == false || 
                 candidate.type == "owned" ||       
                 ( wnd_className == "Internet Explorer_TridentDlgFrame" && wnd_text == "About Internet Explorer" )
               )
            {
                // no close dialog sequence available; close the window directly
                trace("trying smart close...");
                var bHandled = sbmPlugin.SmartClose( wnd );
                if  ( false == bHandled )
                {
                    trace("smart close failed - closing forcibly...");
                    hardClose( wnd );
                }
            }
            else
            {
                trace("window is NOT eligible for smart/hard closing");
            }
        }
        wndsAlreadyTried.push( wnd );
        oncompletion(); return; // invoke caller's continuation & return
    }

    function closeAllWindowsGracefully(toplevels, oncompletion)
    {
        if ( toplevels.length == 0 )
        {
            oncompletion(); return; // invoke caller's continuation & return
        }
        var toplevel = toplevels[0];
        var candidate = getNextWindowToClose(toplevel); // get next candidate for this toplevel
        if ( null == candidate )
        {
            toplevels.shift(); // no more candidates; we are done with current toplevel
            closeAllWindowsGracefully(toplevels, oncompletion);
        }
        else 
        {
            processCandidateForClosing( toplevel, 
                                        candidate, 
                                        function()
                                        {
                                            // continue processing this toplevel (until no more candidates)
                                            closeAllWindowsGracefully(toplevels, oncompletion); 
                                        }
                                      );
        }
    }

    if ( undefined == oncompletion )
    {
        trace("error: continuation 'oncompletion' is undefined");
        return;
    }
    if ( true == bCloseBWDialogs ) // should we close BW dialogs first?
        BWSystem.CloseAllBridgletDialogs();

    var toplevels;
    if ( isWebApp )
    {
        var browsers = [];
        Actions.BrowserRegistry.ForEach( function (browser) { browsers.push(browser); } );
        toplevels = map( function (browser) 
                            { 
                                try { return BWWin32.WindowWithId(browser.Window); } catch (e) { return undefined; }
                            }, 
                         browsers );
        trace ("Web bridge - browser toplevel HWNDs=", map(getHWNDFromWnd, toplevels));
    }
    else
    { 
        var managedWnd = getManagedWindow();
        if (null != managedWnd)
        {
            trace( "Win32 bridge - the managed window HWND=", getHWNDFromWnd(managedWnd) );
            toplevels = [ managedWnd ];
        }
        else 
        {
            toplevels = sbmPlugin.GetAllAppWindowsFromTrackedProcesses();
            trace( "Win32 bridge - no managed window; all app toplevel HWNDs=", map(getHWNDFromWnd, toplevels) );
        }
    }
    closeAllWindowsGracefully( toplevels, oncompletion );
}

///////////////////////////////////////////////////////////////////////////
// app-level helper functions
//
function PerformReauthenticationCustomHandler()
{
    var result = RPCtoAuthenticator();

    if ( result == true ) 
    {
       //
       // Reauthentication succeeded -- continue executing this reauth sequence
       //
       return; 
    }
    //  
    // Reauthentication failed -- use Close All Dialogs to clean up the app,
    // then terminate/restart all the reauth sequences.
    //
    // Although we are not a "blocking" custom function, we do NOT want the 
    // calling sequence to continue once we reach this point (because the
    // rest of the calling sequence is the reauth "success" driver--to be
    // executed only upon reauth success).
    //
    // Instead, we want Close All Dialogs (and Close Dialogs sequences, if any) 
    // to run. The call to SetBlocking will achieve this for us.
    //
    this.SetBlocking(); // ensure calling sequence does not continue

    CloseAllDialogsCPS( true,
                        function () // the continuation of CAD
                        {
                           startSequences( ReauthenticationWatcherDrivers );
                        }
                      );
     // warning: Close Dialog sequences do not execute until we return
     return;
}

///////////////////////////////////////////////////////////////////////////
// RPC call to Authenticator.  Returns true on successful reauthentication, false otherwise.
function RPCtoAuthenticator()
{
    BWContext.InitializeAction();
    BWContext.SetActionValue("[sentillion.com]AuthRequest.id.timeoutSeconds","180");
    BWContext.SetActionValue("[sentillion.com]AuthRequest.id.parentHWND",getManagedWindow());
    BWContext.SetActionValue("[sentillion.com]AuthRequest.id.Message","Please enter credentials");

    var itemsOut;
    try 
    {
        itemsOut = BWContext.PerformAction(false);
    } 
    catch (e) 
    {
        // action failed; return false 
        trace("Reauthentication failed: BWContext.PerformAction threw an exception: e.description=" + e.description);
        return false;
    }

    if (null != itemsOut)
    {
        itemsOut = itemsOut.toArray(); // convert the safearray to a jscript array
        var len = itemsOut.length;
        var result = "";
        var code, msg, val, i;
        trace("PerformAction returned " + len + " items");

        for(i = 0; i < len; i++)
        {
            val = itemsOut[i].toLowerCase();
            if ("[sentillion.com]authresponse.id.result" == val)
            {
                result = itemsOut[i + 1].toLowerCase();
            }
            else if ( "[sentillion.com]authresponse.id.failreasoncode" == val)
            {
                code = itemsOut[i + 1];
            }
            else if ("[sentillion.com]authresponse.id.failreasonmessage" == val)
            {
                msg = itemsOut[i + 1];
            }
            trace("PerformAction item[" + i + "]: " + itemsOut[i]);
        }
        if ("fail" == result)
        {
            trace("Reauthentication failed: code = " + code + ", message = '" + msg + "'");
            return false;
        }
        else if ("pass" == result)
        {
            trace("Reauthentication successful");
            return true;
        }
        else
        {
            trace("PerformAction unknown result: " + result);
            return false;
        }
    }
}

///////////////////////////////////////////////////////////////////////////
function handleAppStartupSuccess(nextSequence)
{
    trace();

    try 
    {
        BWSystem.ReleaseBridgeLock(); // lock may be acquired during app startup
        trace("bridge lock released");
    } 
    catch(e) 
    { 
        // lock was not acquired during app startup
    }

    setManagedWindowFromSequences( [ nextSequence ] );
    setManagedBrowserFromSequences( [ nextSequence ] );

    if ( BridgeOptions.AutoMinimizeOnPatientSearch && !isAnyAppWindowInForeground() )
        try 
        {
            // App is not in foreground, and an immediate patient follow would
            // minimize it; this is not desirable, so activate the app now.
            BWWin32.Activate ( getManagedWindow() );
            trace(" managed window has been activated");
        }
        catch (e) 
        {
            trace("exception: failed to activate main window: ", e.description);
        }

    // move to work area
    if (BridgeOptions.moveToWorkArea) moveToWorkArea();

    // The following statement also stops the caller sequence. 
    // Therefore no actions can be defined after the current step of 
    // the caller sequence (this function call executes to 
    // completion, however).
    if (nextSequence.seqname == 'DriveThruLogin')
    {
        stopAllSequences();
    }
    else
    {
        stopAllSequencesExcept( [WatchForApplicationStartLogon] );
    }
    
    // We have just quit the application and come back around
    if (bRestartingApplication)
    {
        bRestartingApplication = false;
        bRestarted = true;
    }

    // register for before navigate event
    var browser = getManagedBrowser();
    if (browser)
    {
        try
        {
            // register for on before navigation
            browser.RegisterForBeforeNavigate("MainBrowserOnBeforeNavigate", "*");
        }
        catch (e)
        {
            trace("exception: failed to register for before navigate: ", e.description);
        }
    }

    // If this is the initial app startup and not an app
    // restart occurrence, the model needs to be initialized.
    // The model will process the login, else we are here
    // after the model has already been initialized, so the
    // bridge needs to process the login manually.
    if (nextSequence.seqname == 'DriveThruLogin')
    {
        if (bStartup && !bRestarted)
        {
            g_standardBridgeModel.InitializeModel(); 
            bStartup = false;

            startSequences( [WatchForApplicationExit] );

            if ( BridgeOptions.LinkStatusEnabled )
            {
                var linkStatusUpdateThread = function () 
                    { 
                        //trace("updating link status");
                        updateLinkStatus(); 
                        spf.later(linkStatusUpdateThread, 2000); // repeat every 2 secs
                    };
                linkStatusUpdateThread(); // start the 'thread'
            }
        }
        else if (g_standardBridgeModel.IsLoggingIn())
        {
            setManagedWindowFromSequences( [ nextSequence ] );
            startSequences( [nextSequence] );
        }
        else if (g_standardBridgeModel.IsLoggingOut())
        {
            setManagedWindowFromSequences( [ nextSequence ] );
            // do not force logout on startup...
            g_standardBridgeModel.OnLogoutComplete();
        }
        // startup should be reset
        bStartup = false;
    }    
    else
    {
        setManagedWindowFromSequences( [ nextSequence ] );
        startSequences( [nextSequence] );
    }
}

///////////////////////////////////////////////////////////////////////////
// terminateTheApp()
//
// bGracefully:
//   true       Close All Dialogs MAY use Close Dialogs sequences to gracefully 
//              close app dialogs newly raised during this call.
//   false      Close All Dialogs may NOT use Close Dialogs sequences, as such 
//              sequences might hang the bridge.
function terminateTheApp(bGracefully)
{
    trace();
    stopAllSequences();

    var isWebApp = (ApplicationLaunchArgMap.AppType == AppLaunch.isWebApplication);

    function startClosingAppBrowsers()
    {
        Actions.BrowserRegistry.ForEach( 
          function (browser) 
          { 
              trace("terminateTheApp: closing the web browser in window=" + browser.Window);
              try 
              {
                  browser.Close(); // asynchronous (non-blocking) call
                  // will fail if browser dialogs are open;
                  // will throw if browser is invalid or already closed
              }
              catch (e) { }
          } );
          // Warning: the browsers may not yet be closed.
    }

    var OnCloseAllDialogs = function () 
    {
        // we have attempted to gracefully terminate the app.  If the app is still
        // open, we must forcibly terminate it now.

        if ( isWebApp && Actions.BrowserRegistry.Count > 0 )
        {   // try a second time to close app's remaining web browsers. If this attempt also fails,
            // we must then stop the browser's known processes.
            startClosingAppBrowsers();
            var count = 4; // allow up to 4 secs for browsers to close
            while ( Actions.BrowserRegistry.Count > 0 && count > 0 )
            {
                trace("waiting for browser(s) to close...");
                BWSystem.Sleep(1000);  
                count--;
            }
        }
        if ( !isWebApp || Actions.BrowserRegistry.Count > 0 )
        {
            trace("stopping known app processes");
            // Win32 app, or the attempt to close browsers failed
            spf.TrackProcesses.StopKnownProcesses(); // forcibly close app processes
        }
  
        OnTerminateApplication(); // notify

        if (!bRestartingApplication)
            g_standardBridgeModel.OnApplicationTerminate();

        // spf will detect app termination and terminate the bridge
    }

    try 
    {
        if ( isWebApp )
        {
            startClosingAppBrowsers(); // attempt to gracefully terminate this web app
        }
        else
        {
            var wnd = getManagedWindow();
            if (wnd) 
            {
                BWWin32.Close( wnd ); // attempt to gracefully terminate this Win32 app
            }
        }
        // If the attempt to terminate raises 'really quit?' dialogs, close them now.
        // If the attempt to terminate was successful, the following
        // call may throw an exception.
        CloseAllDialogsCPS(true, OnCloseAllDialogs, bGracefully);
        return; // warning: Close Dialogs sequences do not execute until we return
    }
    catch (e) 
    {
        trace("exception: CloseAllDialogsCPS from terminateTheApp: ", e.description);
    }

    OnCloseAllDialogs();
}

///////////////////////////////////////////////////////////////////////////
function splitUrl(url) 
{
    var values = {};

    function isnotEmpty(txt) 
    {
        txt = spf.trim( txt );
        return (txt && "*" != txt) ? true : false;
    }

    function trimasterisks(txt) 
    {
        txt = txt.replace(/^[\*.]+|\*+$/, '');
        return txt;
    }

    // extract out protocol
    url = spf.trim( url );
    var protocol = splitUrl.Protocol.exec(url);
    if (protocol )
    {
        var txt = url.substr(0, protocol.lastIndex);
        if ( isnotEmpty( txt ))
            values.protocol = trimasterisks( txt );

        url = url.substr(protocol.lastIndex);
    }

    // extract out domain
    var indexSlash = url.indexOf('/');
    var domain = (-1 == indexSlash) ? url : url.substr(0, indexSlash);
    if (isnotEmpty(domain)) 
    {
        values.wilddomainstart = (0 == domain.indexOf("*"));
        values.domain = trimasterisks(domain);
    }

    // args
    if (-1 != indexSlash) 
    {
        var args = url.substr(indexSlash + 1);
        if (isnotEmpty(args))
            values.args = trimasterisks( args);
    }

    return (values.domain || values.args || values.protocol)
        ? values : null;
}
splitUrl.Protocol = new RegExp("^(http[s]*|ftp)://");

///////////////////////////////////////////////////////////////////////////
function splitUrlRegEx(url) 
{
    var values = splitUrl(url);
    if (!values)
        return values;

    if (values.domain) 
    {
        // domain needs to have (^|\\.) as a starter
        var domain = values.domain;

        var starter = values.wilddomainstart ? "(^|\\.)" : "^";
        domain = starter + Actions.wildcardToRegExpText(values.domain) + "$";
        values.domain = new RegExp( domain, "i" );
    }

    if (values.args)
        values.args = new RegExp(Actions.wildcardToRegExpText(values.args), "i" );

    if (values.protocol) 
    {
        var protocol = "^" + Actions.wildcardToRegExpText( values.protocol ) + "$";
        values.protocol = new RegExp( protocol, "i" );
    }

    return values;
}

///////////////////////////////////////////////////////////////////////////
// **execute pre-nav if the Agent has not shown any interest in this URL**
//
// check the URL before the main browser navigate to it.
// Spawn a browser if the URL deviates from the site.
function MainBrowserOnBeforeNavigate(_eventId, _browser, _targetUrl, _targetFrame, _postData, _headers)
{
    
    try 
    {
        trace( "MainBrowserOnBeforeNavigate:", _targetUrl );
        if (0 == MonitorUrlsRegEx.length )
            return;

        if (-1 == _targetUrl.indexOf("javascript:")) 
        {
            var targetUrl = splitUrl(_targetUrl);
            if ( !targetUrl )
                return;

            var deviating = true;
            for (var i in MonitorUrlsRegEx ) 
            {
                var monUrl = MonitorUrlsRegEx[i];

                // if not a valid domain, ignore the rest
                if (monUrl.domain && !monUrl.domain.exec(targetUrl.domain))
                    continue;

                // if not matching args
                if (monUrl.args && !monUrl.args.exec(targetUrl.args))
                    continue;

                // if not matching protocol
                if (monUrl.protocol && !monUrl.protocol.exec(targetUrl.protocol))
                    continue;

                // matches everything, so not deviating
                deviating = false;
                break;
            }

            if ( deviating )
            {
                trace("_targetUrl=" + _targetUrl + " matched no Monitor URL; user is deviating from app domain.");

                //we are deviating from the app site
                _browser.CancelNavigation();

                // open it in a new window
                trace( "MainBrowserOnBeforeNavigate:", _targetUrl );
                BWWeb.StartWebBrowser( _targetUrl );
            }
        }
    }
    catch(e)
    {
        trace.Exception( e );
    }
}

///////////////////////////////////////////////////////////////////////////
function detectAppStartFromSequence(sequence)
{
    var wxdef = getFirstWxdefFromSequence(sequence, false );

    if ( null == wxdef )
    {
        return Actions.ReturnSuccess(); // will terminate the sequence
    }

    if ( 'windowdef' == wxdef.wxtype )
    {
        return Actions.WaitWindow({ windowdef: wxdef });
    }
    else if ( 'webdef' == wxdef.wxtype )
    {
        return Actions.WaitDocumentComplete({ webdef: wxdef });
    }
    else
    {
        trace("error");
    }
}

///////////////////////////////////////////////////////////////////////////
// Place link status message on all app windows, except for windows named in
// the LinkStatusWindowExclusionsList.
function updateLinkStatus()
{
    var wnds = [];
    // Get active window from SBM (window definition may have changed and not match Window defs in the bridge)
    var wnd = getManagedWindow();
    if (wnd)
    {
        wnds.push(wnd);
    }

    // Get all window defs in the bridge
    for (var wname in Windows)
    {
        if ( !isMemberOf(wname, LinkStatusWindowExclusionsList) )
        {
            wnd = getWindowFromWindowDef( Windows[wname] );
            if ( wnd && !isMemberOf(wnd, wnds) )
            {
                wnds.push(wnd);
            }
        }
    }
    // Update all window defs with bridge link status
    // Note - DisplayLinkState must perform NOOP when window is invalid (i.e. no error)
    for (var i in wnds)
    {
        //trace("updating HWND=", getHWNDFromWnd(wnds[i]));
        g_standardBridgeModel.DisplayLinkState( wnds[i] );
    }
}

///////////////////////////////////////////////////////////////////////////
function isMemberOf(elt, elts)
{
    for (var i = 0; i < elts.length; i++)
    {
        if ( elt == elts[i] )
        {
            return true;
        }
    }
    return false;
}

///////////////////////////////////////////////////////////////////////////
// apply mapper to elements of array a, returning new mapped array
function map (mapper, a)
{
    var new_a = new Array();
    for (var i = 0; i < a.length; i++)
    {
        new_a.push( mapper( a[i] ));
    }
    return new_a;
}

///////////////////////////////////////////////////////////////////////////
// flatten array of arrays into a single flat array
function flatten(aofa)
{
   var flat_a = [];
   for (var i in aofa)
   {
      flat_a = flat_a.concat( aofa[i] );
   }
   return flat_a;
}

///////////////////////////////////////////////////////////////////////////
// cloneStep() - create a clone of Action 'step'
//
// Useful because concurrently running sequences must not share steps
// (e.g., LogoutSuccessWatchers and LogoutSuccessThenTerminateWatchers must have
// no step objects in common.)
function cloneStep(step)
{
    var new_step = {};
    for (var n in step)
        new_step[n] = step[n];
    return new_step;
}

///////////////////////////////////////////////////////////////////////////
function PatientSet(appText, clearcontext)
{

//This code will replace the match use (marked with '/**/')
//if the actions value input for WaitWindowTextChange supports regexp
//var newMRN = appText; 

    var newMRN = "";

/**/var match = new RegExp(BridgeOptions.ValidMRNRegexp).exec(appText);
/**/if ( match )
/**/{
/**/    for (var i = 1; i < match.length; i++)
/**/    {
/**/        if ( '' != match[i] )
/**/        { 
/**/           newMRN = match[i]; // 1st matched subexpression of the r.e. is the new MRN
/**/           break;
/**/        }
/**/    }
/**/    if (!newMRN && (match.length > 0))
/**/    {
/**/        newMRN = match[0];
/**/    }
/**/}
/**/else if (clearcontext)
/**/{
/**/        newMRN = "";
/**/        match = new RegExp("^\\s*$").exec(appText);
/**/}

    if (match)
    {
        if ( currentMRN != newMRN )
        {
            trace("Successful set detected - newMRN=", newMRN); 
            currentMRN = newMRN;
            g_standardPatientModel.OnSetSubjectSuccess(sbmPlugin.SubjectType.ST_PATIENT, newMRN);
            // NOTE: patient set watchers restarted in EnterSubjectSet callback
        }
        else
        {
            // restart the patient set watchers - this will restart the current watcher
            trace("MRN matches existing context - restarting watchers"); 
            startSequences( PatientSetWatchers );
        }
/**/}
    else // no match case, still need to restart patient
    {
        // restart the patient set watchers - this will restart the current watcher
        trace("MRN does not match regex - restarting watchers"); 
        startSequences( PatientSetWatchers );
    }    
}

///////////////////////////////////////////////////////////////////////////
//                                                                       //
//                     Standard Bridge Model Callbacks                   //
//                                                                       //
///////////////////////////////////////////////////////////////////////////
// The Standard Bridge Model calls back to the bridge upon key events.
//
// Callbacks for User Context
function ContextChangeFinish() 
{
    trace(); 
    if (g_standardBridgeModel.m_bridgeState == g_standardBridgeModel.BS_CREDENTIALS_DISPLAYED)
    {
        bStartup = false;
    }
}

///////////////////////////////////////////////////////////////////////////
function CancelContextChange() { trace(); } // unimplemented
function CloseAllDialogs() { trace(); } // unimplemented and deprecated
function ContextChangeStart() { trace(); } // unimplemented

///////////////////////////////////////////////////////////////////////////
// Notification
function OnBridgeStateChange(newStateName) 
{ 
    trace("new bridge state=" + newStateName); 
    if (g_standardBridgeModel.m_bridgeState == g_standardBridgeModel.BS_CREDENTIALS_DISPLAYED)
    {
        bStartup = false;
    }
// VBDTConsole.updateBridgeState(newStateName);
}

///////////////////////////////////////////////////////////////////////////
// OnAcquireBridgeLock() - currently used for a single purpose:
// to continue app startup when the bridge lock is enabled.
function OnAcquireBridgeLock()
{
    trace();
    StartApplication2(); // immediately start the app
}

///////////////////////////////////////////////////////////////////////////
function EnterLoggedIn(previousBridgeState) 
{ 
    if (__override('entry'))
    {
        return;
    }
    //$$entry, EnterLoggedIn, entry
    trace();
    if (BridgeOptions.TerminateOnApplicationTimeOut || BridgeOptions.TerminateOnManualLogout)
    {
        startSequences( LogoutSuccessThenTerminateWatchers ); // supports manual logout
    }
    else
    {
        startSequences( LogoutSuccessWatchers ); // supports manual logout
    }
    // here the assumption is that all the expired sequences are the same, 
    // only the notification changes. so just take the first one.  Note for documentation.
    if (BridgeOptions.ManualChangePassword && (DriveThruChangePasswordLoginSequences.length > 0))
    {
        startSequences(DriveThruChangePasswordLoginSequences);
    }

    // If (1) Reauthentication is enabled for this bridge, and 
    //    (2) we automated this login (the previous bridge state was BS_LOGGING_IN), 
    // then automated reauthentication is also enabled for this login; therefore, start the 
    // reauthentication automation sequences (if any) now.
    if ( Bridge.BridgeOptions.ReauthenticationEnabled && ReauthenticationWatcherDrivers.length > 0 )
    {    
        if ( g_standardBridgeModel.BS_LOGGING_IN == previousBridgeState )
            startSequences( ReauthenticationWatcherDrivers );
        else 
            stopSequences( ReauthenticationWatcherDrivers );
    }

    if ( Bridge.BridgeOptions.PatientLinkOn )
    {
        // initialize patient support - patient model starts in SS_CLEAR
        currentMRN = undefined; // indicate no MRN currently set by patient set watcher

        // If this is a single patient synchronized bridge, and patient set
        // watchers are defined, start them here.  Note: these watchers
        // will detect manual patient selection and (if defined) patient
        // follow success.
        if (BridgeOptions.PatientLinkOn && ( PatientSetWatchers.length > 0 ))
        {
            startSequences( PatientSetWatchers );
        }
        if ( bAutoMinimizeStrategy )
        {
            startSequences( [ RestoreAppWatcher ] );
        }
   }
    //$$exit, EnterLoggedIn
}

///////////////////////////////////////////////////////////////////////////
function EnterLoggedOut()
{ 
    if (__override('entry'))
    {
        return;
    }
    //$$entry, EnterLoggedOut, entry
    trace();
    stopAllSequencesExcept( LogoutSuccessThenTerminateWatchers, LogoutOutcomeThenTerminateWatchers );
    if ( sbmPlugin.LinkState.LS_SUSPENDED == g_standardBridgeModel.GetLinkState() )
    {
        if ( BridgeOptions.EnableRepeatedLogins )
        {
            trace("Repeated login enabled; starting a new login.");
            // Defer a forced context change.  Otherwise, it will occur "too soon"
            // and the link state will remain "suspended".
            Actions.RegisterForTimer( function (eventid, elapsed, item)
                                        { 
                                            trace("Repeated login enabled; timer handler");
                                            g_standardBridgeModel.m_strContextUsername = null;
                                            g_standardBridgeModel.OnReadyForChange();
                                        }, 
                                        0, 
                                        null, 
                                        true );
        }
        else 
        {
            startSequences( LoginSuccessWatchers ); //  supports manual login
        }
    }
    else 
    {
        DriveAppToLoginReady();        startSequences( LoginSuccessWatchers ); //  supports manual login
    }
    //$$exit, EnterLoggedOut
}

///////////////////////////////////////////////////////////////////////////
function OnLinkStateChange() 
{ 
    var s;
    switch (g_standardBridgeModel.GetLinkState())
    {
        case sbmPlugin.LinkState.LS_SUSPENDED:
        {
            s = "LS_SUSPENDED";
            break;
        }
        case sbmPlugin.LinkState.LS_ON:
        {
            s = "LS_ON";
            break;
        }
        case sbmPlugin.LinkState.LS_OFF:
        {
            s = "LS_OFF";
            break;
        }
        case sbmPlugin.LinkState.LS_CHANGING:
        {
            s = "LS_CHANGING";
            break;
        }
        default:
        {
            s = "** Error: unknown link state **";
        }
    }
    trace ("link state changing to: " + s);
}

///////////////////////////////////////////////////////////////////////////
// DriveAppToLoginReady()
//
// Starts the DriveToLogon (D2L) sequences
function DriveAppToLoginReady()
{
    trace();
    var DriveAppToLoginReady_k = function () // the continuation of DriveAppToLoginReady
    {
        var wxdef = getFirstWxdefFromSequence( LoginDrivers[0], false );

        // if the window is already displayed or
        // no DriveToLogon sequences are defined
        // then just continue/return, else start
        // the DriveToLogon sequence(s).
        if ( ( 'windowdef' == wxdef.wxtype && 
               isWindowDisplayed( getWindowFromWindowDef( wxdef ))) ||
             0 == DriveToLogonSequences.length )
        {
            return;
        }
        trace("starting drive to login ...");
        startSequences( DriveToLogonSequences );
    }

    if (!bStartup)
    {
        // close any open dialogs...
        CloseAllDialogsCPS (true, DriveAppToLoginReady_k);
        // warning: Close Dialog sequences do not execute until we return
        return;
    }
    DriveAppToLoginReady_k();
}

///////////////////////////////////////////////////////////////////////////
// IsReadyForChange()
//
// supports the AutoMinimize feature
function IsReadyForChange() 
{ 
    trace();
    return !bPatientChangeDelayed;
}

///////////////////////////////////////////////////////////////////////////
function OnCancelCredentialsLearning() { trace(); } // unimplemented
function OnCancelPasswordLearning() { trace(); } // unimplemented

///////////////////////////////////////////////////////////////////////////
function OnTerminateApplication() 
{
    trace();
    if (bRestartingApplication)
    {
        // reset startup flag
        bStartup = true;
        // start
        StartApplication();
        return;
    }
    BWSystem.ExitBridglet();
}

///////////////////////////////////////////////////////////////////////////
function OnLaunchPadActivate(eventId)
{
    trace();
    try
    {
        // if browser instance
        var browser = getManagedBrowser();
        if ( browser )
        {        
            browser.Activate();
            return;
        }
    }
    catch(e){}

    try
    {
        // if window instance
        var wnd = getManagedWindow();
        if (wnd)
        {
            // Actions helper function
            Actions.BringWindowToForeground( wnd );
            return;
        }
    }
    catch (e) {
        trace("(1) caught exception bringing window to foreground: "+ e.description);
    }

    // Either we have not defined a managed browser or window 
    // (always true for, e.g., an auditing-only bridge), or the attempt to use it 
    // has failed.  
    //
    // Try again to activate the app by foregrounding the first visible app window found.
    
    var allWnds = sbmPlugin.GetAllAppWindowsFromTrackedProcesses();
    for (var i = 0; i < allWnds.length; i++)
    {
        var wnd = allWnds[i];
        if ( !isWindowDisplayed(wnd) )
            continue;
        try {
            Actions.BringWindowToForeground(wnd);
        }
        catch (e) {
            trace("(2) caught exception bringing window to foreground: "+ e.description);
            continue;
        }
        break;
    }
}

///////////////////////////////////////////////////////////////////////////
// OnLaunchPadClose (OLPC) Event Handler
//
// OLPC Warning: if Close Dialogs or Logout sequences require foreground, they will
// fail if the screen is locked.
function OnLaunchPadClose(eventId)
{
    trace();

    // We may encounter race conditions with, for example, the sequences started by 
    // StartLogUserOut on a user context change.  So, we now make an assertion that
    // is intended to inhibit other event processing.
    bClosingApplication = true; // assert that we are now closing

    bRestartingApplication = false;

    if ( 0 == LogoutSequences.length )
    {
        // If no Logout sequences are defined, assume the app can be closed
        // forcibly and terminate it now. This strategy may successfully
        // avoid the issue with foreground and screen locking described 
        // in the OLPC Warning above.
        terminateTheApp(false);
        return;
    }
    else
    {
        if ( g_standardBridgeModel.BS_LOGGING_OUT == g_standardBridgeModel.GetBridgeState() )
        {
            // a bridged logout is already in progress; assume the Logout sequences are already running and allow 
            // them to complete.
            trace("Logout is already in progress");
            stopAllSequencesExcept( LogoutSequences );
            startSequences( LogoutOutcomeThenTerminateWatchers ); // watch for logout, then terminate the app
            return;
        }
        else 
        {
            // a bridged logout is not in progress.  We will attempt a graceful logout from here.  
            stopAllSequences(); 
            CloseAllDialogsCPS(true,
                               function () // the continuation of OnLaunchPadClose
                               {
                                   startSequences( LogoutSequences ); // drive thru logout, if possible
                                   startSequences( LogoutOutcomeThenTerminateWatchers ); // if logged out, terminate the app
                               });
            // warning: Close Dialog sequences do not execute until we return
            return;
        }
    }
}

///////////////////////////////////////////////////////////////////////////
/// StartLogUserIn()
///
/// @summary
///    this (model-to-bridge) callback handles user login.  
///
/// @model-state
///    entering BS_LOGGING_IN
///
/// @model-based-objectives 
///     If application login screen is not already displayed, starts the navigation to
///     login page.
///
///     When the login screen is displayed, logs the user into the application.
/// 
///     Upon completion of this login sequence, the bridge must:
///       * call this.OnloginComplete() (which signals model.OnLoginSuccess()) if login succeeded, or 
///       * call this.OnLoginFailure(eReason) (which signals model.OnLoginFail()) if login failed.
///
/// @preconditions
///     * a context change has occurred or the model has been initialized by signalling
///       model.InitializeModel().
///     * model is in one of these states:
///          BS_LOGGED_OUT
///          BS_PWL_DISPLAYED
///          BS_CREDENTIALS_DISPLAYED
///          BS_PW_EXPIRED
///     * context contains 'umaid' entry
///     * context contains bridge suffix entry
///           or
///       self-enrollment has occurred (Note: SE requires BridgeOptions.SeMaxAttempts > 0)
///     * template function this.GetMainWindowId() is defined
///
/// @inputs
///     strUsername    - current username to be logged into application
///     eReason        - active model processing action; valid values:
///                        LoginReason.UserChange
///                        LoginReason.PwlRetry
///                        LoginReason.PwExpired
///                        LoginReason.CredentialsRetry
///     nRetry         - number of tries in current mode (not used)
///     strOldPassword - previous password (used with password expiration processing)
///
/// @responsibilities
///    * if login screen is already up, performs the login by calling this.OnLoginStart().
///    * if login screen is not already up, 
///        ** drives the app to the login screen (if necessary)
///        ** watches app for transition to state "login screen ready", after which performs the
///           login.
///
/// @responsibilities-success
///     On successful completion, the bridge state remains in BS_LOGGING_IN.
/// 
/// @responsibilities-failure
///     On detecting an error, must call this.OnLoginFailure(failReason) (which signals
///     model.OnLoginFail(failReason)).
/// 
/// @on-transition-success
///     Upon detecting a successful login, bridge calls this.OnLoginComplete()
///     (which signals model.OnLoginSuccess()).
///
///     The success condition is detected by a known event (RegisterForCreate, RegisterForDestroy,
///     etc.) or through timing inspection (RegisterForTimer).
/// 
/// @on-transition-failure
///     Upon detecting a login error, bridge calls this.OnLoginFailure(failReason) (which signals
///     model.OnLoginFail(failReason)).  failReason is one of the following:
///         VERGENCE_DIALOG_ACQUIRE_PASSWORD_PURPOSE.PASSWORD_INCORRECT
///         VERGENCE_DIALOG_ACQUIRE_PASSWORD_PURPOSE.PASSWORD_EXPIRED
///         VERGENCE_DIALOG_ACQUIRE_PASSWORD_PURPOSE.PASSWORD_USER_CHANGE (this reason code is also used
///         to indicate a general failure)
///         (other reason codes are used internally by the model)
///
///      The failure condition is detected by a known event handler (RegisterForCreate,
///      RegisterForDestroy, etc.) or through timing inspection (RegisterForTimer) in order to set
///      the bridge state to BS_LOGGED_OUT, BS_PWL_DISPLAYED, BS_CREDENTIALS_DISPLAYED, or
///      BS_PW_EXPIRED.
///
function StartLogUserIn(strUsername, eReason, nRetry, strOldPassword) 
{ 
    if (__override('entry'))
    {
        return;
    }
    //$$entry, StartLogUserIn(strUsername, eReason, nRetry, strOldPassword), entry, exit 
    trace();

    if ( bClosingApplication )
    {
        // We are already closing the application (e.g., an OLPC is in-progress)
        // and we must not interfere with this.
        return;
    }

    stopAllSequences();

    // Inform spf of pending username and password(s) (necessary for %keyword%
    // substitution).
    spf.State.setUserName( strUsername );
    spf.State.setPassword( BWContext.GetPassword() );
    spf.State.setOldPassword( strOldPassword );

    var StartLogUserIn_k = function ()  // the continuation of StartLogUserIn
    {
        trace("startloguserin_k");
        switch(eReason)
        {
            case sbmPlugin.LoginReason.PwExpired:
            {
                trace("expired");
                // DriveThruExpiredPasswordLogin must be set by the corresponding EP
                // notification-dismiss sequence.
                setManagedWindowFromSequences( [ DriveThruExpiredPasswordLogin ] );
                startSequences( [ DriveThruExpiredPasswordLogin ] );
                break;
            }
            case sbmPlugin.LoginReason.PwlRetry: // Password Learning (PWL)
            {
                trace("PWL");
                DriveAppToLoginReady();
                setManagedWindowFromSequences( LoginDrivers );
                startSequences( LoginDrivers );
                break;
            }
            case sbmPlugin.LoginReason.CredentialsRetry: // Self-Enrollment (SE)
            {
                trace("retry");
                DriveAppToLoginReady();
                setManagedWindowFromSequences( LoginDrivers );
                startSequences( LoginDrivers );
                break;
            }
            case sbmPlugin.LoginReason.UserChange:
            {
                trace("userchange");
                if (!bStartup && BridgeOptions.TerminateOnContextChange)
                {
                    bRestartingApplication = BridgeOptions.RestartEnabled;
                    terminateTheApp(true); // terminate gracefully
                }
                else
                {
                    DriveAppToLoginReady();
                    setManagedWindowFromSequences( LoginDrivers );
                    startSequences( LoginDrivers );
                }
                break;
            }
            default:
            {
                trace("StartLogUserIn: unknown eReason=" + eReason);
            }
        }
    }

    CloseAllDialogsCPS (true, StartLogUserIn_k);
    // warning: Close Dialog sequences do not execute until we return
    //$$exit, StartLogUserIn
    if (__override('exit'))
    {
        return;
    }
}

/// StartLogUserOut()
///
/// @summary 
/// This (model-to-bridge) callback is invoked:
///    (1) to handle user logout, and
///    (2) to return the application to a known initial (logged out) state.
///
/// @model-state
///     entering BS_LOGGING_OUT
///
/// @model-based-objectives
///     This callback is invoked when a user context change occurs and certain conditions apply as
///     described below. It performs the graceful logout of the application.  
///
///     After invocation, successful logout transition is completed by calling the template
///     function this.OnLogoutFinished() (which signals model.OnLogoutComplete()).
///
///     Notes: 
///       * a logout failure is considered a serious error; the bridge must signal
///         model.OnLogoutFail() and shut down the application.
///
///       * applications that don't support a logout process may be restarted.  The bridge should
///         shut down the application in this case.  The re-launching is handled in the registered
///         termination event handler.
///
///       * Some apps may launch to a state in which either a user login or navigation to the login
///         menu cannot be immediately performed.  This callback is also used to deal with such
///         cases (see preconditions below).
///
/// @preconditions
///     * a context change has occured or the model has been initialized by signalling
///       model.InitializeModel().
///
///     * any model state except BS_LOGGING_IN or BS_LOGGING_OUT.
///
///     * this callback is also invoked if model.m_bForceLogout or model.m_bAlwaysCallLogout is set
///       to true (even if the model is in the BS_LOGGED_OUT state).  This is used to return the app
///       to a known initial state from which either login or navigation to the login menu may then
///       proceed.
///
/// @inputs: none
///
/// @responsibilities 
///     Upon completion of the logout sequence, the bridge must signal model.OnLogoutComplete().  The
///     bridge should shut down the application if it cannot logout. See responsibilities-failure
///     below.
///
/// @responsibilities-success
///     On completion, the bridge state remains in BS_LOGGING_OUT.
///
/// @responsibilities-failure
///     Upon error, must signal model.OnLogoutFail() and exit the application.
///
/// @on-transition-success
///     Successful completion of app logout should be detected by an event handler or
///     through timing inspection.   These must in turn signal model.OnLogoutComplete()
///     in order to set the bridge state to BS_LOGGED_OUT.
/// 
/// @on-transition-failure
///     Unsuccessful completion of the app logout process will be detected by a known event handler
///     or through timing inspection.  (See also responsibilities-failure above).
///
function StartLogUserOut() 
{ 
    if (__override('entry'))
    {
        return;
    }
    //$$entry, StartLogUserOut, entry, exit 
    trace();

    if ( bClosingApplication )
    {
        // We are already closing the application (e.g., an OLPC is in-progress)
        // and we must not interfere with this.    
        return;
    }
    
    // If this instance of the application has not already logged in once
    // before, initialize the restarting flag
    if (!bStartup)
    {
        bRestartingApplication = BridgeOptions.RestartEnabled;
    }
    else
    {
        // do not force logout on startup...
        g_standardBridgeModel.OnLogoutComplete();
        // startup should be reset
        bStartup = false;
        return;
    }
    CloseAllDialogsCPS (true, 
                        function () // the continuation of StartLogUserOut
                        {
                            if ( 0 < LogoutSequences.length )
                            {
                                startSequences( LogoutSequences );
                                if (!bStartup && BridgeOptions.TerminateOnContextChange)
                                {
                                    startSequences( LogoutOutcomeThenTerminateWatchers );
                                }
                                else
                                {
                                    startSequences( LogoutOutcomeWatchers );
                                }
                            }
                            else 
                            {
                                terminateTheApp(true); // terminate gracefully
                            }
                        });
    // warning: Close Dialog sequences do not execute until we return
    //$$exit, StartLogUserOut
    if (__override('exit'))
    {
        return;
    }
}

///////////////////////////////////////////////////////////////////////////
// Callbacks for Patient Context

// called upon entry to SS_SET
function EnterSubjectSet()
{ 
    if (__override('entry'))
    {
        return;
    }
    //$$entry, EnterSubjectSet, entry
    trace();
    // If the bridge is here because a PatientSetWatcher executed 
    // a PatientSetWatchers and set the patient subject, 
    // this will reset the patient set watchers (if appropriate)
    if (BridgeOptions.PatientLinkOn && ( PatientSetWatchers.length > 0 ))
    {
        startSequences( PatientSetWatchers );
    }
    if ( bAutoMinimizeStrategy )
    {
        startSequences( [ RestoreAppWatcher ] );
    }
    //$$exit, EnterPatientSet
}

// called upon entry to SS_CLEAR
//
// Note: the patient model's initial state is SS_CLEAR, and this does
// not count as a state transition (that is, EnterSubjectClear is *not* called
// at model initialization time).
function EnterSubjectClear()
{ 
    if (__override('entry'))
    {
        return;
    }
    //$$entry, EnterSubjectClear, entry
    trace();
    currentMRN = undefined; // indicate no MRN currently set by patient set watcher

    // This will restart PatientSetWatchers (if appropriate) after a ClearPatientDrivers sequence
    if (BridgeOptions.PatientLinkOn && ( PatientSetWatchers.length > 0 ))
    {
        startSequences( PatientSetWatchers );
    }
    if ( bAutoMinimizeStrategy )
    {
        startSequences( [ RestoreAppWatcher ] );
    }
    //$$exit, EnterSubjectSet
}

/// SetSubject()
///
/// @summary 
///     Start the process of setting a new patient from a context 
///     change (follow patient selection from another application).
///     Upon completion of the user selecting the patient in the application,
///     the Bridge must call the template function OnChangePatient(). Or if failed,
///     call the model signal model.OnSetSubjectFailure() directly. 
///
/// @model-state
///     entering SS_SETTING
///
/// @preconditions
///     * a context change has occured with a patient different than the one 
///     * selected in the application.
///     * bridge cannot be suspended at the user level (i.e., after a manual
///      logout/login)
///
/// @inputs: 
///     subjectType - the SubjectType enum value ST_PATIENT. 
///          Note: neither the template nor sbmPlugin currently provides
///          support for multi-level subjects, e.g., both ST_PATIENT and
///          ST_ENCOUNTER.
///     strSubject  - the new subject value to be set into context.
///
/// @model-objectives
///   The Model objective for this transition is to process the pending
///   patient context change. Automates the application so that the desired
///   patient is selected in the application.  The pending context change is
///   complete when the Bridge signals model.OnSetSubjectSuccess() or
///   model.OnSetSubjectFailure().
///
///   On set subject failure, if a subject existed previously, the subject
///   state will be SS_SET, else it is returned to SS_CLEAR.  Bridge
///   link-state is LS_CHANGING until success/failure, then LS_ON.
///
/// @on-function-success
///     On completion, the subject state is SS_SETTING.
///
/// @on-transition-success
///     Successful completion of the subject change or some error conditions 
///       should be detected by an event handler or through a timer callback.
///       Success conditions must call model.OnSetSubjectSuccess in order to
///       set the subject state to SS_SET.
/// 
/// @on-function-failure
///     call OnSetSubjectFail.
/// 
/// @on-transition-failure 
///     Failure handling must call model.OnSetSubjectFail which will set the
///     subject state to SS_SET or SS_CLEAR (if there was a previous subject
///     or not).
///
/// @timing 
///     The patient change process is delayed when applications are minimized
///     to avoid situations where application controls must be visible for
///     bridge automation to function. Delayed operations are processed in
///     the OnRestore handler through OnReadyForChange.
///
function SetSubject(subjectType, strSubject)
{ 
    if (__override('entry'))
    {
        return;
    }
    //$$entry, SetSubject(subjectType, strSubject), entry
    trace();

    if ( BridgeOptions.AutoMinimizeOnPatientSearch && !isAnyAppWindowInForeground() )
    {
        CloseAllDialogsCPS(true,
                           function () // the continuation of auto-minimize
                           {
                               trace("App does not have foreground - delaying patient set");
                               bPatientChangeDelayed = true;
                               stopSequences( PatientSetWatchers );
                               BWWin32.Minimize( getManagedWindow() );
                               // signal failure now (must not block within SS_SETTING)
                               g_standardPatientModel.OnSetSubjectFail(sbmPlugin.SubjectType.ST_PATIENT);
                           });
        // warning: Close Dialog sequences do not execute until we return
        return;
    }

    // Inform spf of pending patient MRN (necessary for %keyword% substitution).
    spf.State.setMRN( strSubject );
  
    // test if patient following has been defined
    if ( FollowPatientDrivers.length > 0 )
    {
        CloseAllDialogsCPS(true,
                           function () // the continuation of SetSubject
                           {
                               startSequences( FollowPatientDrivers );
                           });
        // warning: Close Dialog sequences do not execute until we return
        return;
    }
    else
    {
        // no patient following is defined.
        g_standardPatientModel.OnSetSubjectFail(subjectType);
    }
    //$$exit, SetSubject
}

/// ClearSubject()
///
/// @summary 
///     Start the process of clearing an existing patient in the application 
///     Upon completion of the patient selection in the application,
///     the Bridge must call the template function this.OnClearPatient(). 
///     Or if failed, then call the mode signal model.OnClearSubjectFail() directly.   
///
/// @model-state
///     entering SS_CLEARING
///
/// @preconditions
///     from SS_SET subject state or no Subject state (initial state entry);
///     bridge cannot be suspended
///
/// @inputs: none
///
/// @model-objectives 
///     Bridge subject state when entering is SS_CLEARING.
///     The Model calls this function when subject context is cleared and prior
///        to initiating new subject context changes through SetSubject. Bridge
///        processing of this transition must detect success or failure through
///        known event occurances or registered timer handlers.   In both cases
///        subject state will be SS_CLEAR.  
///     Bridge linkstate is set to LS_CHANGING, on success it is set to LS_ON,
///        on failure it is set to LS_SUSPENDED.
///
/// @on-function-success
///     On completion, the subject state is SS_CLEARING.
///
/// @on-transition-success
///     Successful completion of the subject clear should be detected by an
///       event handler or a timer callback.   Success conditions must call
///       model.OnClearSubjectComplete(), and will set the subject state to
///       SS_CLEAR.
/// 
/// @on-function-failure
///     call OnClearSubjectFail.  When a bridge supports multi-level subjects, 
///     then failure should pass next subjectType to automate type processing
///     heirarchy.
/// 
/// @on-transition-failure
///     OnClearSubjectFail does not block subsequent SetSubject processing.
///     Unsuccessful completion of the subject clear should be detected by
///       an event handler or a timer callback.  These functions must call
///       model.OnClearSubjectFail().  Subject state will be SS_CLEAR.
///
/// @timing
///     The subject change process is delayed when applications are minimized
///     to avoid situations where application controls must be visible for
///     bridge automation to function. Delayed operations are processed in
///     the OnRestoreMyApplication handler through OnReadyForChange.
///
function ClearSubject(subjectType)
{ 
    if (__override('entry'))
    {
        return;
    }
    //$$entry, ClearSubject(subjectType), entry
    trace();

    if ( BridgeOptions.AutoMinimizeOnClearPatient && !isAnyAppWindowInForeground() )
    {
        CloseAllDialogsCPS(true,
                           function () // the continuation of auto-minimize
                           {
                               trace("App does not have foreground - delaying patient clear");
                               bPatientChangeDelayed = true;
                               stopSequences( PatientSetWatchers );
                               BWWin32.Minimize( getManagedWindow() );
                               // Signal now (we must not block within SS_CLEARING).
                               // Logically we have failed to clear, but we do not want to signal failure at this time
                               // (if we then place null patient into context, fail causes an unwanted SBM popup: 
                               // "A patient was selected in another application but ...")
                               g_standardPatientModel.OnClearSubjectComplete(sbmPlugin.SubjectType.ST_PATIENT);
                               // Causes the Link state to be set properly
                               g_standardPatientModel.OnSetSubjectFail(sbmPlugin.SubjectType.ST_PATIENT);
                           });
        // warning: Close Dialog sequences do not execute until we return
        return;
    }

    if ( ClearPatientDrivers.length > 0 )
    {
        // Patient clearing has been defined.

        // PatientSetWatchers are stopped to avoid generating a
        // patient context change with the cleared patient result in the app.
        // PatientSetWatchers are restarted in the EnterSubjectClear function.
        stopSequences(PatientSetWatchers);

        CloseAllDialogsCPS(true,
                           function () // the continuation of ClearSubject
                           {
                               startSequences( ClearPatientDrivers );
                           });
        // warning: Close Dialog sequences do not execute until we return
        return;
    }
    else
    {
        trace("Clearing patient context - signalling failure"); 
        // Stop all sequences (except those listed below) to avoid triggering certain
        // sequences while patient clear. This provides support for, e.g., manual logout
        // while patient clear.
        var exceptSequences = [].concat( DriveThruChangePasswordLoginSequences, 
                                         LogoutSuccessWatchers, 
                                         LogoutSuccessThenTerminateWatchers, 
                                         ReauthenticationWatcherDrivers,
                                         PatientSetWatchers );
        stopAllSequencesExcept( exceptSequences );
        // initially signal failure - this covers case where no clear sequences are
        // provided (success is always signaled from clear sequence)
        g_standardPatientModel.OnClearSubjectFail(sbmPlugin.SubjectType.ST_PATIENT);
    }
    //$$exit, ClearSubject
}

///////////////////////////////////////////////////////////////////////////
// Searches for an override in the form __prefix_originalname and if found
// calls it and returns a value
///////////////////////////////////////////////////////////////////////////
function __override(prefix, name)
{
    trace();
    try
    {
        // get calling function
        var fn = arguments.callee.caller;
        // get function name from script
        var fname = "";
        if (name)
        {
            fname = name;
        }
        else
        {
            var fscript = "" + fn;
            fname = tracePlugin.functionInfo( fscript, 'anonymous' );
        }
        // add optional prefix
        if (prefix)
            fname = "" + prefix + "_" + fname;
        // add __ prefix
        fname = "__" + fname;
        //trace("fname=" + fname);
        // see if override exists
        var fover = null;
        try
        {
            fover = eval(fname);   
        }
        catch (e)
        {
            fover = null;
        }
        if (fover)
        {
            trace("Calling override: "+fname);
            return fover.apply(null, fn.arguments);
        }
    }
    catch (e)
    {
        trace ("Exception: "+e.description);
    }
    return false;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
var bRestarted = false;
var bRestartingApplication = false;
var bClosingApplication = false;  // OnLaunchPadClose sets to true
var bStartup = true;  // app is in startup phase (requires model init, etc.)
var currentMRN;         // the MRN currently set by a patient set watcher

///////////////////////////////////////////////////////////////////////////

///////////////////// END GENERATED FUNCTIONS //////////////////////////

////////////////////////////////////////////////////////////////////////
// Custom JavaScript overrides
//
// Bridge Developer: to override any of the following definitions,
// first copy them to the CUSTOM FUNCTIONS section below. Do not
// edit these definitions here (or your edits will be lost).

// To disable link status message display for selected windows, add the
// Window object property names (as strings) to the list below.
var LinkStatusWindowExclusionsList = [ ];

// To disable selected toplevel windows from closing consideration by
// CloseAllDialogs, add their windowdefs to the list below.
var CloseAllDialogsWindowDefExclusionsList = [ ];

// To change the Windowdef used by the Restore App Watcher, change
// the Windows property reference below.
var RestoreAppWatcherWaitWindowdef = Windows.logout1_window_0;
//
////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////
//
// The CUSTOM OVERRIDE FUNCTIONS section below contains JavaScript functions and other
// code that is to be reimportable (retained across saves) by the Wizard.
//
// This section may contain code that is referenced/defined through the wizard
// using overrides for SBM, SPF functions
// (e.g. StartLogUserIn)
//
//
//////////////////////  BEGIN CUSTOM OVERRIDE FUNCTIONS //////////////////////////
//////////////////////  END CUSTOM OVERRIDE FUNCTIONS //////////////////////////

////////////////////////////////////////////////////////////////////////
//
// The CUSTOM FUNCTIONS section below contains JavaScript functions and other
// code that is to be reimportable (retained across saves) by the Wizard.
//
// This section may contain manually added code that is referenced through the wizard
// using custom action definitions, or that is referenced by internal bridge/SBM logic
// (e.g. ParseBridgeCommandLine)
//
//////////////////////  BEGIN CUSTOM FUNCTIONS //////////////////////////



//////////////////////  END CUSTOM FUNCTIONS //////////////////////////

///////////////////////////////////////////////////////////////////////////
// startup and initialization functions
Initialize();
main(); // start the bridge
///////////////////////////////////////////////////////////////////////////

